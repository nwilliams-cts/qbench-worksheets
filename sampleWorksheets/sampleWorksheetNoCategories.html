{% set ns = namespace() %}
{# Residual Solvents - Assay ID: 52 #}
{% set ns.worksheet_assay_id = 52 %}

<style>
  /* Smithers Corporate Color Scheme */
  :root {
    --smithers-navy-dark: #0a2240;
    --smithers-navy: #003a70;
    --smithers-blue: #236092;
    --smithers-yellow: #f6cd3e;
    --smithers-yellow-light: #fedb54;
    --smithers-gray-dark: #48484a;
    --smithers-gray: #cdcfd0;
    --smithers-gray-light: #e7eaec;
  }

  /* Container Styling */
  .qbench-worksheet-container #ws-tabs {
    margin-bottom: 1rem;
    display: flex;
    flex-wrap: wrap;
    background: var(--smithers-gray-light);
    border-radius: 8px 8px 0 0;
    padding: 5px 5px 0 5px;
  }

  /* Tab Buttons */
  .qbench-worksheet-container .ws-tab-btn {
    float: left;
    padding: 12px 24px;
    text-decoration: none;
    margin-right: 2px;

    /* Smithers colors */
    color: white;
    background: var(--smithers-navy-dark);
    cursor: pointer;
    font-weight: 500;
    border: none;
    border-radius: 8px 8px 0 0;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .qbench-worksheet-container .ws-tab-btn:hover {
    background: var(--smithers-blue);
    transform: translateY(-1px);
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
  }

  .qbench-worksheet-container .ws-tab-btn.active {
    background: var(--smithers-navy);
    font-weight: 700;
    z-index: 3;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  /* Tab Container */
  .qbench-worksheet-container .ws-tab-container {
    background: white;
    border-radius: 0 0 8px 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    padding: 20px;
  }

  /* Table Defaults */
  .qbench-worksheet-container .ws-tab-content table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1rem;
  }

  .qbench-worksheet-container .ws-tab-content th,
  .qbench-worksheet-container .ws-tab-content td {
    border: 1px solid #ccc;
    padding: 8px 12px;
    text-align: center;
  }

  .qbench-worksheet-container .ws-tab-content th {
    background: var(--smithers-gray-light);
    color: var(--smithers-navy-dark);
    font-weight: 600;
    white-space: nowrap;
    border-bottom: 2px solid var(--smithers-gray);
  }

  .qbench-worksheet-container .ws-tab-content td input[type="number"] {
    width: 100%;
    box-sizing: border-box;
    padding: 6px 8px;
    border: 1px solid var(--smithers-gray);
    border-radius: 4px;
    transition: border-color 0.3s ease;
  }

  .qbench-worksheet-container .ws-tab-content td input[type="number"]:focus {
    outline: none;
    border-color: var(--smithers-blue);
    box-shadow: 0 0 0 2px rgba(35, 96, 146, 0.2);
  }

  /* Row Highlighting */
  .qbench-worksheet-container tr[data-ws-analyte]:hover {
    background-color: #f0f8ff;
  }

  /* Overall Status Banner */
  .qbench-worksheet-container .overall-status-banner {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    margin: 10px 0 20px 0;
    border-radius: 6px;
    font-weight: 600;
    font-size: 1rem;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    width: 75%;
    margin: 20px auto;
  }

  .qbench-worksheet-container .overall-status-banner.pass {
    background: #d4f6d4;
    border: 1px solid #28a745;
    color: #155724;
  }

  .qbench-worksheet-container .overall-status-banner.warning {
    background: #fff9c4;
    border: 1px solid #ffc107;
    color: #856404;
  }

  .qbench-worksheet-container .overall-status-banner.fail {
    background: #f8d7da;
    border: 1px solid #dc3545;
    color: #721c24;
  }

  .qbench-worksheet-container .compliance-badge {
    padding: 4px 10px;
    border-radius: 16px;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }

  .qbench-worksheet-container .compliance-badge.compliant {
    background: #28a745;
    color: white;
  }

  .qbench-worksheet-container .compliance-badge.pending {
    background: #ffc107;
    color: #333;
  }

  .qbench-worksheet-container .compliance-badge.non-compliant {
    background: #dc3545;
    color: white;
  }

  .qbench-worksheet-container .compliance-badge.info {
    background: #6c757d;
    color: white;
  }

  /* Status Icons */
  .qbench-worksheet-container .status-icon {
    font-weight: bold;
    margin-right: 8px;
  }

  .qbench-worksheet-container .status-icon.pass {
    color: #28a745;
  }

  .qbench-worksheet-container .status-icon.fail {
    color: #dc3545;
  }

  .qbench-worksheet-container .status-icon.warning {
    color: #ffc107;
  }

  .qbench-worksheet-container .status-icon.unknown {
    color: #6c757d;
  }

  /* Status Cell Styling */
  .qbench-worksheet-container .status-pass {
    background: #d4edda !important;
    color: #155724 !important;
    font-weight: 600;
  }

  .qbench-worksheet-container .status-warning {
    background: #fff3cd !important;
    color: #856404 !important;
    font-weight: 600;
  }

  .qbench-worksheet-container .status-fail {
    background: #f8d7da !important;
    color: #721c24 !important;
    font-weight: 600;
  }

  .qbench-worksheet-container .status-unknown {
    background: #e2e3e5 !important;
    color: #6c757d !important;
    font-weight: 600;
  }

  /* RSD Status Styling */
  .qbench-worksheet-container .rsd-pass {
    background: #d4edda !important;
    color: #155724 !important;
  }

  .qbench-worksheet-container .rsd-warning {
    background: #fff3cd !important;
    color: #856404 !important;
  }

  .qbench-worksheet-container .rsd-fail {
    background: #f8d7da !important;
    color: #721c24 !important;
  }

  /* RSD Tooltip Styling */
  .qbench-worksheet-container .rsd-tooltip {
    position: relative;
    border-bottom: 1px dotted #666;
  }

  .qbench-worksheet-container .rsd-tooltip:hover {
    background-color: rgba(0, 123, 255, 0.1);
    border-radius: 3px;
  }

  /* Enhanced tooltip for better visibility */
  .qbench-worksheet-container .rsd-tooltip[title]:hover::after {
    content: '';
    position: absolute;
    top: -5px;
    right: -5px;
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-bottom: 5px solid #333;
    z-index: 1001;
  }

  /* Result Type Styling */
  .qbench-worksheet-container .result-nt {
    background: #e2e3e5 !important;
    color: #383d41 !important;
    font-style: italic;
  }

  .qbench-worksheet-container .result-nd {
    background: #d1ecf1 !important;
    color: #0c5460 !important;
    font-style: italic;
  }

  .qbench-worksheet-container .result-loq {
    background: #fff3cd !important;
    color: #856404 !important;
    font-style: italic;
  }

  /* Critical Value Highlighting */
  .qbench-worksheet-container .critical-value {
    background: #ff8c00 !important;
    color: white !important;
    font-weight: bold;
  }

  /* Summary Table Highlight */
  #ws-tab-summary table th,
  #ws-tab-summary table td {
    text-align: right;
  }

  #ws-tab-summary table td:first-child {
    font-weight: 600;
    text-align: left;
  }

  /* Statistics Table Styling */
  #ws-tab-statistics table th,
  #ws-tab-statistics table td {
    text-align: right;
    font-size: 0.9rem;
  }

  #ws-tab-statistics table td:first-child {
    font-weight: 600;
    text-align: left;
  }

  #ws-tab-statistics table th {
    font-size: 0.85rem;
    background-color: #e9ecef;
  }

  /* Homogeneity Table Styling */
  #ws-tab-homogeneity table th,
  #ws-tab-homogeneity table td {
    text-align: center;
    font-size: 0.9rem;
    padding: 8px 4px;
  }

  #ws-tab-homogeneity table td:first-child {
    font-weight: 600;
    text-align: left;
  }

  #ws-tab-homogeneity table th {
    font-size: 0.85rem;
    background-color: #e9ecef;
  }

  #ws-tab-homogeneity .hom-status-pass {
    background-color: #d4edda;
    color: #155724;
  }

  #ws-tab-homogeneity .hom-status-fail {
    background-color: #f8d7da;
    color: #721c24;
  }

  /* Summary table homogeneity status styling */
  .ws-summary-homogeneity.hom-status-pass {
    background-color: #d4edda;
    color: #155724;
    font-weight: 600;
  }

  .ws-summary-homogeneity.hom-status-fail {
    background-color: #f8d7da;
    color: #721c24;
    font-weight: 600;
  }

  /* Unit Selector */
  #unit-selector {
    margin: 0.5rem 0;
    padding: 8px 12px;
    border: 2px solid var(--smithers-gray);
    border-radius: 6px;
    background: white;
    color: var(--smithers-navy-dark);
    font-size: 0.9rem;
    transition: all 0.3s ease;
  }

  #unit-selector:focus {
    outline: none;
    border-color: var(--smithers-blue);
    box-shadow: 0 0 0 3px rgba(35, 96, 146, 0.2);
  }

  /* Multi-Unit Output Selector */
  .multi-unit-selector-group {
    margin: 15px 0;
    padding: 15px;
    border: 1px solid var(--smithers-gray);
    border-radius: 8px;
    background: #f8f9fa;
  }

  .multi-unit-selector-group h4 {
    margin: 0 0 10px 0;
    color: var(--smithers-navy-dark);
    font-size: 1rem;
    font-weight: 600;
  }

  .multi-unit-selector-group .unit-checkboxes {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
  }

  .multi-unit-selector-group .unit-checkbox-item {
    display: flex;
    align-items: center;
    gap: 6px;
    min-width: 80px;
  }

  .multi-unit-selector-group input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: var(--smithers-blue);
    cursor: pointer;
  }

  .multi-unit-selector-group label {
    color: var(--smithers-navy-dark);
    font-weight: 500;
    cursor: pointer;
    user-select: none;
  }

  /* Buttons */
  .qbench-worksheet-container button {
    background: linear-gradient(135deg, var(--smithers-blue) 0%, var(--smithers-navy) 100%);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .qbench-worksheet-container button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .qbench-worksheet-container button:active {
    transform: translateY(0);
  }

  .qbench-worksheet-container button:disabled {
    background: var(--smithers-gray);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  /* Primary Button (Yellow) */
  .qbench-worksheet-container button.btn-primary,
  .qbench-worksheet-container #unlock-data-btn {
    background: linear-gradient(135deg, var(--smithers-yellow) 0%, var(--smithers-yellow-light) 100%);
    color: var(--smithers-navy-dark);
    font-weight: 600;
  }

  /* Danger Button */
  .qbench-worksheet-container button.btn-danger,
  .qbench-worksheet-container #lock-data-btn {
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
  }

  /* Moisture Settings in Settings Tab */
  .qbench-worksheet-container .moisture-settings-group {
    background: #f8f9fa;
    border: 1px solid var(--smithers-gray);
    border-radius: 6px;
    padding: 16px;
    margin: 16px 0;
  }

  .qbench-worksheet-container .moisture-settings-group h4 {
    margin: 0 0 12px 0;
    color: var(--smithers-navy-dark);
    font-size: 1rem;
  }

  .qbench-worksheet-container .moisture-settings-group label {
    display: block;
    margin: 8px 0;
    font-weight: normal;
  }

  .qbench-worksheet-container .moisture-settings-group input[type="checkbox"] {
    margin-right: 8px;
  }

  /* Settings Form Controls */
  .ws-tab-content input[type="number"],
  .ws-tab-content select,
  .ws-tab-content input[type="text"] {
    border: 1px solid var(--smithers-gray);
    border-radius: 4px;
    padding: 6px 8px;
    transition: border-color 0.3s ease;
  }

  .ws-tab-content input:focus,
  .ws-tab-content select:focus {
    outline: none;
    border-color: var(--smithers-blue);
    box-shadow: 0 0 0 2px rgba(35, 96, 146, 0.2);
  }

  /* Data Integrity Controls */
  .data-integrity-controls {
    background: var(--smithers-gray-light);
    border: 2px solid var(--smithers-gray);
    border-radius: 8px;
    padding: 15px;
    margin: 15px 0;
  }

  .data-integrity-controls h4 {
    color: var(--smithers-navy-dark);
    margin-top: 0;
    border-bottom: 2px solid var(--smithers-gray);
    padding-bottom: 8px;
  }

  .protection-status {
    margin-left: 10px;
    padding: 4px 8px;
    border-radius: 4px;
    font-weight: bold;
    font-size: 0.8rem;
  }

  .protection-status.locked {
    background: #dc3545;
    color: white;
  }

  .protection-status.unlocked {
    background: #ffc107;
    color: #333;
  }

  /* Legend Section */
  .legend-section {
    background: var(--smithers-gray-light);
    border: 1px solid var(--smithers-gray);
    border-radius: 8px;
    padding: 15px;
    margin: 20px 0;
  }

  .legend-section h4 {
    color: var(--smithers-navy-dark);
    margin-top: 0;
    border-bottom: 2px solid var(--smithers-gray);
    padding-bottom: 8px;
  }

  .legend-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 20px;
    margin-top: 15px;
  }

  .legend-grid>div {
    background: white;
    padding: 15px;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    line-height: 1.6;
  }

  .legend-grid strong {
    display: block;
    margin-bottom: 8px;
    color: var(--smithers-navy-dark);
  }

  .legend-grid span {
    margin-right: 8px;
    margin-bottom: 4px;
    display: inline-block;
  }

  /* Sample Information Section */
  .sample-info-section {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 1px solid var(--smithers-gray);
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  }

  .sample-info-section h3 {
    margin: 0 0 15px 0;
    color: var(--smithers-navy-dark);
    font-size: 1.3rem;
    font-weight: 600;
    border-bottom: 2px solid var(--smithers-blue);
    padding-bottom: 8px;
  }

  .sample-info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
  }

  .sample-info-card {
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    padding: 15px;
  }

  .sample-info-card h4 {
    margin: 0 0 12px 0;
    color: var(--smithers-navy);
    font-size: 1rem;
    font-weight: 600;
  }

  .sample-info-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 8px 0;
    padding: 6px 0;
    border-bottom: 1px solid #f8f9fa;
  }

  .sample-info-item:last-child {
    border-bottom: none;
  }

  .sample-info-label {
    font-weight: 500;
    color: var(--smithers-navy-dark);
  }

  .sample-info-value {
    font-weight: 600;
    color: var(--smithers-navy);
  }

  .sample-info-value.missing {
    color: #dc3545;
    font-style: italic;
  }

  .sample-info-value.available {
    color: #28a745;
  }

  .unit-availability-note {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 4px;
    padding: 10px;
    margin-top: 10px;
    font-size: 0.9rem;
    color: #856404;
  }

  /* Buttons */
  .qbench-worksheet-container button {
    background: linear-gradient(135deg, var(--smithers-blue) 0%, var(--smithers-navy) 100%);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .qbench-worksheet-container button:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .qbench-worksheet-container button:active {
    transform: translateY(0);
  }

  .qbench-worksheet-container button:disabled {
    background: var(--smithers-gray);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  /* Primary Button (Yellow) */
  .qbench-worksheet-container button.btn-primary,
  .qbench-worksheet-container #unlock-data-btn {
    background: linear-gradient(135deg, var(--smithers-yellow) 0%, var(--smithers-yellow-light) 100%);
    color: var(--smithers-navy-dark);
    font-weight: 600;
  }

  /* Danger Button */
  button.btn-danger,
  #lock-data-btn {
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
  }

  /* Settings Form Controls */
  .ws-tab-content input[type="number"],
  .ws-tab-content select,
  .ws-tab-content input[type="text"] {
    border: 1px solid var(--smithers-gray);
    border-radius: 4px;
    padding: 6px 8px;
    transition: border-color 0.3s ease;
  }

  .ws-tab-content input:focus,
  .ws-tab-content select:focus {
    outline: none;
    border-color: var(--smithers-blue);
    box-shadow: 0 0 0 2px rgba(35, 96, 146, 0.2);
  }

  /* Responsive */
  @media (max-width: 768px) {

    .ws-tab-content table,
    .ws-tab-content th,
    .ws-tab-content td {
      font-size: 0.85rem;
    }
  }

  /* Table sorting styles */
  .summary-sortable,
  .stats-sortable {
    cursor: pointer;
    user-select: none;
    position: relative;
    padding-right: 20px !important;
  }

  .summary-sortable:hover,
  .stats-sortable:hover {
    background-color: #e9ecef;
  }

  .summary-sortable::after,
  .stats-sortable::after {
    content: '↕';
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0.3;
    font-size: 12px;
  }

  .summary-sortable.sort-asc::after,
  .stats-sortable.sort-asc::after {
    content: '↑';
    opacity: 1;
    color: #0066cc;
  }

  .summary-sortable.sort-desc::after,
  .stats-sortable.sort-desc::after {
    content: '↓';
    opacity: 1;
    color: #0066cc;
  }

  /* RSD Status Styling */
  .rsd-pass {
    background-color: #d4edda !important;
    color: #155724 !important;
  }

  .rsd-warning {
    background-color: #fff3cd !important;
    color: #856404 !important;
  }

  .rsd-fail {
    background-color: #f8d7da !important;
    color: #721c24 !important;
    font-weight: bold !important;
  }

  .rsd-status-indicator {
    font-size: 0.8em;
    font-weight: bold;
    margin-left: 5px;
  }

  /* Enhanced Status Styling */
  .status-pass {
    background-color: #d4edda !important;
    color: #155724 !important;
    font-weight: bold !important;
  }

  .status-fail {
    background-color: #f8d7da !important;
    color: #721c24 !important;
    font-weight: bold !important;
  }

  .status-unknown {
    background-color: #e2e3e5 !important;
    color: #383d41 !important;
  }

  /* Result Type Indicators */
  .result-nt {
    background: var(--smithers-gray) !important;
    color: var(--smithers-navy-dark) !important;
    border-radius: 4px;
    font-weight: 600;
  }

  .result-nd {
    background: var(--smithers-blue) !important;
    color: white !important;
    border-radius: 4px;
    font-weight: 600;
  }

  .result-loq {
    background: var(--smithers-yellow) !important;
    color: var(--smithers-navy-dark) !important;
    border-radius: 4px;
    font-weight: 600;
  }

  .result-above-curve {
    background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%) !important;
    color: white !important;
    border-radius: 4px;
    font-weight: 600;
    border: 2px solid #e65100 !important;
  }

  /* RSD Status Indicators */
  .rsd-pass {
    background: #28a745 !important;
    color: white !important;
    border-radius: 4px;
    font-weight: 600;
  }

  .rsd-warning {
    background: var(--smithers-yellow) !important;
    color: var(--smithers-navy-dark) !important;
    border-radius: 4px;
    font-weight: 600;
  }

  .rsd-fail {
    background: #dc3545 !important;
    color: white !important;
    border-radius: 4px;
    font-weight: 600;
  }

  /* Limit Warning Indicators */
  .limit-warning {
    background: linear-gradient(135deg, var(--smithers-yellow-light) 0%, var(--smithers-yellow) 100%) !important;
    color: var(--smithers-navy-dark) !important;
    border-radius: 4px;
    font-weight: 600;
  }

  .critical-value {
    background: linear-gradient(135deg, #ff6b6b 0%, #dc3545 100%) !important;
    color: white !important;
    border-radius: 4px;
    font-weight: 600;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0% {
      opacity: 1;
    }

    50% {
      opacity: 0.7;
    }

    100% {
      opacity: 1;
    }
  }

  /* LOQ QC Warning - when LOQ exceeds action limit */
  .loq-qc-warning {
    background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%) !important;
    color: white !important;
    border-radius: 4px;
    font-weight: 600;
    border: 2px solid #e65100 !important;
    animation: qc-alert 3s infinite;
  }

  @keyframes qc-alert {
    0% {
      box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7);
    }

    50% {
      box-shadow: 0 0 0 4px rgba(255, 152, 0, 0.3);
    }

    100% {
      box-shadow: 0 0 0 0 rgba(255, 152, 0, 0);
    }
  }

  /* Data Integrity Protection */
  .data-locked {
    background: var(--smithers-gray-light) !important;
    border: 2px solid var(--smithers-gray) !important;
    color: var(--smithers-gray-dark) !important;
    cursor: not-allowed !important;
    opacity: 0.8;
  }

  .data-locked:hover {
    background: #dcdfe2 !important;
    border-color: var(--smithers-gray-dark) !important;
  }

  .data-locked::after {
    content: '🔒';
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    color: #dc3545;
    pointer-events: none;
  }

  /* Locked checkbox styling */
  input[type="checkbox"].data-locked {
    opacity: 0.6 !important;
    cursor: not-allowed !important;
    pointer-events: auto !important;
  }

  input[type="checkbox"].data-locked+label {
    opacity: 0.6 !important;
    cursor: not-allowed !important;
    color: var(--smithers-gray-dark) !important;
  }

  /* Special styling for locked checkbox containers */
  th input[type="checkbox"].data-locked,
  td input[type="checkbox"].data-locked {
    position: relative;
  }

  th input[type="checkbox"].data-locked::after,
  td input[type="checkbox"].data-locked::after {
    content: '🔒';
    position: absolute;
    right: -18px;
    top: -2px;
    font-size: 10px;
    color: #dc3545;
    pointer-events: none;
  }

  .data-deviation-required {
    background: #fff3cd !important;
    border: 2px solid var(--smithers-yellow) !important;
  }

  .data-deviation-logged {
    background: #d1ecf1 !important;
    border: 2px solid var(--smithers-blue) !important;
  }

  .deviation-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(10, 34, 64, 0.8);
    backdrop-filter: blur(2px);
  }

  .deviation-modal-content {
    background: white;
    margin: 5% auto;
    padding: 30px;
    border: none;
    border-radius: 12px;
    width: 85%;
    max-width: 650px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    position: relative;
    animation: modalSlideIn 0.3s ease-out;
  }

  @keyframes modalSlideIn {
    from {
      opacity: 0;
      transform: translateY(-20px) scale(0.95);
    }

    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  .deviation-close {
    color: var(--smithers-gray);
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    transition: color 0.3s ease;
  }

  .deviation-close:hover {
    color: var(--smithers-navy);
  }

  .deviation-form {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .deviation-form label {
    font-weight: 600;
    color: var(--smithers-navy);
    margin-bottom: 5px;
  }

  .deviation-form input,
  .deviation-form select,
  .deviation-form textarea {
    padding: 10px 12px;
    border: 2px solid var(--smithers-gray);
    border-radius: 6px;
    font-size: 0.9rem;
    transition: all 0.3s ease;
  }

  .deviation-form input:focus,
  .deviation-form select:focus,
  .deviation-form textarea:focus {
    outline: none;
    border-color: var(--smithers-blue);
    box-shadow: 0 0 0 3px rgba(35, 96, 146, 0.2);
  }

  .deviation-form textarea {
    min-height: 80px;
    resize: vertical;
    font-family: inherit;
  }

  .deviation-form small {
    color: var(--smithers-gray-dark);
    font-size: 0.8rem;
    margin-top: 5px;
  }

  .deviation-close:hover {
    color: black;
  }

  .deviation-form {
    margin-top: 20px;
  }

  .deviation-form label {
    display: block;
    margin: 10px 0 5px 0;
    font-weight: bold;
  }

  .deviation-form input,
  .deviation-form textarea,
  .deviation-form select {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-sizing: border-box;
  }

  .deviation-form textarea {
    height: 80px;
    resize: vertical;
  }

  .data-integrity-controls {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 5px;
    padding: 15px;
    margin: 10px 0;
  }

  .protection-status {
    display: inline-block;
    padding: 6px 16px;
    border-radius: 20px;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-left: 10px;
    transition: all 0.3s ease;
  }

  .protection-status.locked {
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
    color: white;
    box-shadow: 0 2px 6px rgba(220, 53, 69, 0.3);
  }

  .protection-status.unlocked {
    background: linear-gradient(135deg, var(--smithers-yellow) 0%, var(--smithers-yellow-light) 100%);
    color: var(--smithers-navy-dark);
    box-shadow: 0 2px 6px rgba(246, 205, 62, 0.3);
  }

  /* Data Integrity Controls Section */
  .data-integrity-controls {
    background: linear-gradient(135deg, var(--smithers-gray-light) 0%, #f0f2f5 100%);
    border: 2px solid var(--smithers-gray);
    border-radius: 10px;
    padding: 25px;
    margin: 20px 0;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  }

  .data-integrity-controls h4 {
    color: var(--smithers-navy);
    margin-top: 0;
    margin-bottom: 20px;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .data-integrity-controls h4::before {
    content: '🔒';
    font-size: 1.1rem;
  }

  /* Settings Tab Styling */
  #ws-tab-settings {
    background: white;
    padding: 25px;
    border-radius: 8px;
  }

  #ws-tab-settings>div {
    margin-bottom: 20px;
    padding: 15px;
    background: var(--smithers-gray-light);
    border-radius: 6px;
    border-left: 4px solid var(--smithers-blue);
  }

  #ws-tab-settings label {
    font-weight: 600;
    color: var(--smithers-navy);
    display: block;
    margin-bottom: 8px;
  }

  /* Deviation Review Styling */
  .deviation-list {
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    background: white;
  }

  .deviation-item {
    border-bottom: 1px solid #e9ecef;
    padding: 15px;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  .deviation-item:hover {
    background-color: #f8f9fa;
  }

  .deviation-item:last-child {
    border-bottom: none;
  }

  .deviation-item.deviation-completed {
    background-color: #f8f9fa;
    border-left: 4px solid #28a745;
  }

  .deviation-item.deviation-active {
    background-color: #fff3cd;
    border-left: 4px solid #ffc107;
  }

  .deviation-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-weight: 600;
  }

  .deviation-id {
    color: #495057;
    font-family: monospace;
    background: #e9ecef;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 0.9em;
  }

  .deviation-status {
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.8em;
    text-transform: uppercase;
    font-weight: 600;
  }

  .deviation-completed .deviation-status {
    background: #d4edda;
    color: #155724;
  }

  .deviation-active .deviation-status {
    background: #fff3cd;
    color: #856404;
  }

  .deviation-time {
    color: #6c757d;
    font-size: 0.9em;
    font-weight: normal;
  }

  .deviation-summary {
    color: #495057;
    font-size: 0.9em;
    line-height: 1.4;
  }

  .deviation-details {
    margin-top: 15px;
    border-top: 1px solid #e9ecef;
    padding-top: 15px;
  }

  .deviation-review-close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    line-height: 1;
    cursor: pointer;
    transition: color 0.3s ease;
  }

  .deviation-review-close:hover {
    color: #000;
  }

  /* Legend Section */
  .legend-section {
    background: linear-gradient(135deg, #f8f9fa 0%, var(--smithers-gray-light) 100%);
    border: 1px solid var(--smithers-gray);
    border-radius: 8px;
    padding: 20px;
    margin-top: 25px;
  }

  .legend-section h4 {
    color: var(--smithers-navy);
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
  }

  .legend-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
    font-size: 0.9em;
  }

  .legend-grid>div {
    background: white;
    padding: 12px;
    border-radius: 6px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  }

  .legend-grid strong {
    color: var(--smithers-navy);
    display: block;
    margin-bottom: 8px;
    font-size: 0.95em;
  }

  /* Table Sorting Styles */
  .summary-sortable,
  .stats-sortable {
    cursor: pointer;
    user-select: none;
    position: relative;
    padding-right: 20px !important;
    transition: background-color 0.3s ease;
  }

  .summary-sortable:hover,
  .stats-sortable:hover {
    background-color: var(--smithers-blue) !important;
    color: white;
  }

  .summary-sortable::after,
  .stats-sortable::after {
    content: '↕';
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0.6;
    font-size: 0.8em;
  }

  .summary-sortable.sort-asc::after,
  .stats-sortable.sort-asc::after {
    content: '↑';
    opacity: 1;
  }

  .summary-sortable.sort-desc::after,
  .stats-sortable.sort-desc::after {
    content: '↓';
    opacity: 1;
  }

  /* RSD Status Indicator */
  .rsd-status-indicator {
    margin-left: 4px;
    font-weight: bold;
  }

  /* Pulse Animation for Critical Values */
  @keyframes pulse {

    0%,
    100% {
      transform: scale(1);
      background-color: #ff8c00;
    }

    50% {
      transform: scale(1.05);
      background-color: #dc3545;
    }
  }

  .critical-value {
    animation: pulse 2s infinite;
  }

  /* Responsive Design */
  @media (max-width: 768px) {

    .ws-tab-content table,
    .ws-tab-content th,
    .ws-tab-content td {
      font-size: 0.85rem;
    }

    .ws-tab-btn {
      padding: 8px 16px;
      font-size: 0.9rem;
    }

    .overall-status-banner {
      flex-direction: column;
      gap: 8px;
      text-align: center;
      padding: 8px 12px;
    }

    .legend-grid {
      grid-template-columns: 1fr;
    }

    .data-integrity-controls {
      padding: 15px;
    }
  }

  @media (max-width: 480px) {
    .ws-tab-content {
      padding: 10px;
    }

    .ws-tab-content th,
    .ws-tab-content td {
      padding: 4px;
      font-size: 0.8rem;
    }

    .qbench-worksheet-container button {
      padding: 8px 16px;
      font-size: 0.9rem;
    }
  }
</style>

{% set temp_tests = [] %}
{% for test in tests %}
{% if test.assay_id == ns.worksheet_assay_id %}
{% set _x = temp_tests.append(test) %}
{% endif %}
{% endfor %}
{% set tests = temp_tests %}

{% set worksheet = tmp_worksheet_data if tmp_worksheet_data else tests[0].get_worksheet_data() %}
{% set worksheet = worksheet if worksheet else {} %}

{% set assay = tests[0].assay %}
{% set assay_key = assay.title.lower().replace('[sample] ', '').replace(" ", "_") %}
{% set kvstore_id = assay.assay_params or "" %}
{% set kvstore = kvstore_id|get_kvstore_json if kvstore_id else {} %}
{% set analytes = kvstore.get('worksheet_analytes') or [] %}
{% set allowed_units = kvstore.get('allowed_units') %}
{% set input_unit = assay.qc_units %}
{% set limit_unit = kvstore.get('action_limit_units') %}
{% set instrument_data = worksheet.get('ws_instrument_results_' + assay_key) or {} %}
{% set live_data = worksheet.get('ws_live_results_' + assay_key) or {} %}

<!-- Moisture Correction Setup -->
{% set use_moisture_correction = kvstore.get('use_moisture_correction') or false %}
{% set moisture_assay_id = kvstore.get('moisture_assay_id') %}
{% set assay_name = kvstore.get('assay_name') or '' %}
{% set assay_display_name = assay.title or ''%}
{% set ns.moisture_value = 0.0 %}
{% set ns.moisture_found = false %}

{% if use_moisture_correction and moisture_assay_id %}
{% set all_tests = tests[0].sample.tests %}
{% for my_test in all_tests %}
{% if my_test.state == "COMPLETED" and my_test.assay_id == moisture_assay_id %}
{% set ns.moisture_value = my_test.get_worksheet_data()|extract_worksheet_value("moisture_result_reported") or 0.0 %}
{% set ns.moisture_found = true %}
{% endif %}
{% endfor %}
{% endif %}

<!-- QBench Worksheet Container - Scoped for multi-instance support -->
<div class="qbench-worksheet-container">

  {% set instrument_res = "ws_instrument_results_{}".format(assay_key) %}
  {% set live_res = "ws_live_results_{}".format(assay_key) %}
  {% set final_res = "ws_final_results_{}".format(assay_key) %}
  {% set dev_res = "ws_deviations_{}".format(assay_key) %}
  <!-- Data Fields for LIMS Save -->
  <div style="display:none;">__(textarea, {{instrument_res}}, default_value="{}")__</div>
  <div style="display:none;">__(textarea, {{live_res}}, default_value="{}")__</div>
  <div style="display:none;">__(textarea, {{final_res}}, default_value="{}")__</div>
  <div style="display:none;">__(textarea, {{dev_res}}, default_value="[]")__</div>

  <!-- Assay Key Helper for JavaScript -->
  <div style="display:none" id="ws-assay-key">{{ assay_key }}</div>

  <br><br>
  <!-- JSON Config -->
  <script type="application/json" id="ws-unit-config">
  {
    "allowed_units": {{ allowed_units | tojson }},
    "default_units": {{ (kvstore.get('default_units') or ['ppb']) | tojson }},
    "default_number_format": "{{ kvstore.get('default_number_format') or 'fixed_decimals' }}",
    "input_unit": "{{ input_unit }}",
    "limit_unit": "{{ limit_unit }}",
    "report_units": "{{ kvstore.get('report_units') or 'ppb' }}",
    "confident_report_unit": "{{ assay.cc_input_units or 'ppb'}}",
    "rsd_warning_limit": {{ kvstore.get('rsd_warning_limit') or 15 }},
    "rsd_fail_limit": {{ kvstore.get('rsd_fail_limit') or 25 }},
    "rsd_check_enabled": {{ (kvstore.get('rsd_check_enabled') or 'true') | tojson }},
    "use_moisture_correction": {{ use_moisture_correction | tojson }},
    "moisture_value": {{ ns.moisture_value | tojson }},
    "moisture_found": {{ ns.moisture_found | tojson }},
    "assay_name": "{{ assay_name }}",
    "assay_display_name": "{{ assay_display_name }}",
    "default_compliance": {{ (kvstore.get('default_compliance') if kvstore.get('default_compliance') is not none else true) | tojson }},
    "default_uncertainty": {{ (kvstore.get('default_uncertainty') if kvstore.get('default_uncertainty') is not none else false) | tojson }},
    "default_lod_display": {{ (kvstore.get('default_lod_display') if kvstore.get('default_lod_display') is not none else true) | tojson }},
    "default_homogeneity": {{ (kvstore.get('default_homogeneity') if kvstore.get('default_homogeneity') is not none else false) | tojson }},
    "default_decimal_places": {{ kvstore.get('default_decimal_places', 3) }},
    "homogeneity_min_replicates": {{ kvstore.get('homogeneity_min_replicates', 3) }},
    "uncertainty_data": {
      {% for analyte in analytes %}
        "{{ analyte}}_uncertainty": {{ kvstore.get(analyte + '_uncertainty', 0.0)}}{% if not loop.last %},{% endif %}
      {% endfor %}
    },
    "homogeneity_data": {
      {% for analyte in analytes %}
        "{{ analyte}}_homogeneity_limit": {{ kvstore.get(analyte + '_homogeneity_limit', 0.25)}},
        "{{ analyte}}_homogeneity_default": {{ (kvstore.get(analyte + '_homogeneity_default') if kvstore.get(analyte + '_homogeneity_default') is not none else false) | tojson }}{% if not loop.last %},{% endif %}
      {% endfor %}
    },
    "test_status_colors": {{ kvstore.get('test_status_colors', {
      "INTAKE": "#ffbfa1",
      "NOT RECEIVED": "#898989",
      "NEEDS CALC": "#db38ff",
      "NEEDS REVIEW": "#1c76f1",
      "WEIGHED": "#f88800",
      "CC Reviewed - Needs Moisture": "#07a7e5",
      "Internal": "#027110",
      "COC": "#b31ec8",
      "REVIEWED - NEEDS MOISTURE": "#07a7e5",
      "REPLICATE": "#7cbea9",
      "ASSAY AVERAGE": "#81c868",
      "NOT REPORTED": "#045e00",
      "OOS": "#ff672c",
      "CC Internal": "#027110",
      "CC COC": "#b31ec8",
      "CC Replicate": "#7cbea9",
      "CC Not Reported": "#045e00",
      "CC OOS": "#ff672c",
      "NOT STARTED": "#ffbd4a",
      "IN PROGRESS": "#34d3eb",
      "COMPLETED": "#81c868",
      "FOR REVIEW": "#0cf4ee",
      "CANCELLED": "#f05050",
      "QC CONFIRMATION": "#f05050"
    }) | tojson }}
  }
</script>
  <script type="application/json" id="ws-instrument-json">{{ instrument_data | tojson }}</script>
  <script type="application/json" id="ws-live-json">{{ live_data | tojson }}</script>
  <script type="application/json" id="ws-isomers-map">{{ kvstore.get("isomers_map") | tojson }}</script>
  <script type="application/json" id="ws-analyte-info">{{ kvstore.get("analyte_info") | tojson }}</script>
  <script type="application/json" id="ws-sample-info">
  {
    "sample_id": "{{ tests[0].sample.cc_id if tests[0].sample.cc_id else tests[0].sample.custom_formatted_id }}",
    "sample_name": "{{ tests[0].sample.description if tests[0].sample.description else '' }}",
    "sample_qbn_id": {{ tests[0].sample.id if tests[0].sample.id else 'null' }},
    "serving_weight": {{ tests[0].sample.unit_weight if tests[0].sample.unit_weight else 0 }},
    "servings_per_package": {{ tests[0].sample.units_per_package if tests[0].sample.units_per_package else 0 }},
    "sample_type": "{{ tests[0].sample.sample_type_cc if tests[0].sample.sample_type_cc else '' }}"
  }
</script>

  <div id="ws-tabs">
    <button type="button" class="ws-tab-btn active" data-ws-tab="summary">Summary</button>
    {% for t in tests %}
    <button type="button" class="ws-tab-btn" data-ws-tab="{{ t.id }}">Test {{ t.id }}</button>
    {% endfor %}
    <button type="button" class="ws-tab-btn" data-ws-tab="statistics">Statistics</button>
    <button type="button" class="ws-tab-btn" data-ws-tab="homogeneity" style="display:none">Homogeneity</button>
    <button type="button" class="ws-tab-btn" data-ws-tab="sample-info">Sample Info</button>
    <button type="button" class="ws-tab-btn" data-ws-tab="settings">Settings</button>
  </div>

  <div class="ws-tab-content ws-tab-container" id="ws-tab-summary">
    <h4>Summary Statistics</h4>
    <div id="overall-status-banner" class="overall-status-banner">
      <span id="overall-status-text">Calculating overall status...</span>
      <span id="overall-compliance-badge" class="compliance-badge pending">Pending</span>
    </div>
    <table>
      <thead>
        <tr>
          <th class="summary-sortable">Analyte</th>
          <th class="summary-sortable" name="lod-header">LOD ({{ current_display_unit }})</th>
          <th class="summary-sortable" name="loq-header">LOQ ({{ current_display_unit }})</th>
          <th class="summary-sortable" name="final-header">Result ({{ current_display_unit }})</th>
          <th class="summary-sortable ws-compliance-column" name="limit-header">Limit</th>
          <th class="summary-sortable ws-compliance-column">Status</th>
          <th class="summary-sortable ws-homogeneity-column" style="display:none;">Homogeneity</th>
          <th class="summary-sortable">RSD %</th>
        </tr>
      </thead>
      <tbody id="ws-summary-body">
        {% for analyte in analytes %}
        {% set analyte_info = kvstore.get("analyte_info")[analyte] or {} %}
        {% set display_name = analyte_info.get('display_name', "") %}
        <tr data-ws-analyte="{{ analyte }}">
          <td>{{ display_name }}</td>
          <td class="ws-summary-lod" name="ws_lod_{{ analyte }}"></td>
          <td class="ws-summary-loq" name="ws_loq_{{ analyte }}"></td>
          <td class="ws-summary-mean" name="ws_mean_{{ analyte }}"></td>
          <td class="ws-summary-limit ws-compliance-column" name="ws_limit_{{ analyte }}"></td>
          <td class="ws-summary-status ws-compliance-column" name="ws_status_{{ analyte }}"></td>
          <td class="ws-summary-homogeneity ws-homogeneity-column" name="ws_homogeneity_{{ analyte }}"
            style="display:none;"></td>
          <td class="ws-summary-rsd"></td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>

  <div class="ws-tab-content ws-tab-container" id="ws-tab-statistics" style="display:none">
    <h4>Detailed Statistics</h4>
    <table>
      <thead>
        <tr>
          <th class="stats-sortable">Analyte</th>
          <th class="stats-sortable" name="stats-mean-header">Mean ({{ current_display_unit }})</th>
          <th class="stats-sortable" name="stats-std-header">Std Dev ({{ current_display_unit }})</th>
          <th class="stats-sortable" name="stats-rsd-header">RSD %</th>
          <th class="stats-sortable" name="stats-min-header">Min ({{ current_display_unit }})</th>
          <th class="stats-sortable" name="stats-max-header">Max ({{ current_display_unit }})</th>
          <th class="stats-sortable">Count</th>
          <th class="stats-sortable" name="stats-median-header">Median ({{ current_display_unit }})</th>
          <th class="stats-sortable" name="stats-range-header">Range ({{ current_display_unit }})</th>
        </tr>
      </thead>
      <tbody id="ws-statistics-body">
        {% for analyte in analytes %}
        {% set analyte_info = kvstore.get("analyte_info")[analyte] or {} %}
        {% set display_name = analyte_info.get('display_name', "") %}
        <tr data-ws-analyte="{{ analyte }}">
          <td>{{ display_name }}</td>
          <td class="ws-stats-mean" name="ws_stats_mean_{{ analyte }}"></td>
          <td class="ws-stats-std" name="ws_stats_std_{{ analyte }}"></td>
          <td class="ws-stats-rsd" name="ws_stats_rsd_{{ analyte }}"></td>
          <td class="ws-stats-min" name="ws_stats_min_{{ analyte }}"></td>
          <td class="ws-stats-max" name="ws_stats_max_{{ analyte }}"></td>
          <td class="ws-stats-count" name="ws_stats_count_{{ analyte }}"></td>
          <td class="ws-stats-median" name="ws_stats_median_{{ analyte }}"></td>
          <td class="ws-stats-range" name="ws_stats_range_{{ analyte }}"></td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>

  <div class="ws-tab-content ws-tab-container" id="ws-tab-sample-info" style="display:none">
    <h2>📋 Sample & Assay Information</h2>
    <div class="sample-info-grid">
      <div class="sample-info-card">
        <h4>Sample Details</h4>
        <div class="sample-info-item">
          <span class="sample-info-label">Sample ID:</span>
          <span class="sample-info-value" id="display-sample-id">-</span>
        </div>
        <div class="sample-info-item">
          <span class="sample-info-label">Sample Name:</span>
          <span class="sample-info-value" id="display-sample-name">-</span>
        </div>
        <div class="sample-info-item">
          <span class="sample-info-label">Sample Type:</span>
          <span class="sample-info-value" id="display-sample-type">-</span>
        </div>
        <div class="sample-info-item">
          <span class="sample-info-label">QBN ID:</span>
          <span class="sample-info-value" id="display-sample-qbn-id">-</span>
        </div>
        <div class="sample-info-item">
          <span class="sample-info-label">Assay:</span>
          <span class="sample-info-value" id="display-assay-name">-</span>
        </div>
      </div>

      <div class="sample-info-card">
        <h4>Product Information</h4>
        <div class="sample-info-item">
          <span class="sample-info-label">Serving Weight:</span>
          <span class="sample-info-value" id="display-serving-weight">-</span>
        </div>
        <div class="sample-info-item">
          <span class="sample-info-label">Servings per Package:</span>
          <span class="sample-info-value" id="display-servings-per-package">-</span>
        </div>
        <div class="sample-info-item">
          <span class="sample-info-label">Moisture Content:</span>
          <span class="sample-info-value" id="display-moisture-content">-</span>
        </div>
        <div class="sample-info-item">
          <span class="sample-info-label">Selected Units:</span>
          <span class="sample-info-value" id="display-selected-units">-</span>
        </div>
        <div id="unit-availability-warning" class="unit-availability-note" style="display: none;">
          <strong>Note:</strong> <span id="unit-warning-text"></span>
        </div>
      </div>
    </div>
  </div>

  <div class="ws-tab-content ws-tab-container" id="ws-tab-settings" style="display:none">
    <h2>Settings</h2>
    <div>
      <!-- Data Integrity Protection Section (moved to top) -->
      <div class="data-integrity-controls">
        <h4>Data Integrity Protection</h4>
        <div>
          <label for="data-protection-enabled">Lock Instrument Data & Analyte Inclusion:</label>
          <input type="checkbox" id="data-protection-enabled" style="margin-left: 20px;" checked>
          <span id="protection-status" class="protection-status locked">LOCKED</span>
          <br><small style="margin-left: 20px; color: #666;">Prevent unauthorized changes to instrument results and
            analyte inclusion/exclusion</small>
        </div>
        <div>
          <button id="unlock-data-btn"
            style="margin: 10px 20px 10px 0; background-color: #ffc107; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Request
            Data Unlock</button>
          <button id="lock-data-btn"
            style="margin: 10px 0; background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;"
            disabled>Lock Data</button>
        </div>
        <div id="deviation-summary" style="margin-top: 10px; font-size: 0.9em; color: #666;">
          No deviations logged.
        </div>
        <div style="margin-top: 10px;">
          <button id="review-deviations-btn"
            style="background-color: #17a2b8; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">📋
            Review Deviations</button>
          <small style="margin-left: 10px; color: #666;">View all logged data integrity deviations</small>
        </div>
      </div>
      <br>

      <!-- Multi-Unit Output Selector -->
      <div class="multi-unit-selector-group">
        <h4>📊 Output Units Selection</h4>
        <div class="unit-checkboxes" id="multi-unit-checkboxes">
          <!-- Unit checkboxes will be populated by JavaScript -->
        </div>
        <small style="display: block; margin-top: 8px; color: #6c757d; font-style: italic;">
          Select which units to include in final results output. At least one unit must be selected.
        </small>
      </div>

      <!-- Display Unit Selector -->
      <div>
        <label for="display-unit-selector">Table Display Units:</label>
        <select id="display-unit-selector" style="margin-left: 20px; width: 120px;">
          <!-- Options will be populated by JavaScript -->
        </select>
        <small style="display: block; margin-top: 4px; color: #6c757d; font-style: italic;">
          Choose which unit to display in worksheet tables and headers.
        </small>
      </div>
      <br>

      <div>
        <label for="number-format-strategy">Number Format:</label>
        <select id="number-format-strategy" style="margin-left: 20px; width: 220px;">
          <option value="fixed_decimals" selected>Fixed Decimals</option>
          <option value="significant_figures">Significant Figures</option>
        </select>
        <div
          style="font-size: 11px; color: #666; margin-left: 20px; margin-top: 4px; padding: 6px; background: #f8f9fa; border-radius: 4px; border-left: 3px solid #007bff;">
          <strong>Format affects how all numbers are displayed:</strong><br>
          <strong>• Fixed Decimals:</strong> 8.513%, 85.130 mg/g<br>
          <strong>• Significant Figures:</strong> 8.513%, 85.13 mg/g<br><br>
        </div>
      </div>
      <br>

      <div>
        <label for="sig-fig-input">Displayed Sig Figs:</label>
        <input type="number" id="sig-fig-input" min="0" max="5" step="1" style="margin-left: 20px; width: 100px;">
        <small style="display: block; margin-top: 4px; color: #6c757d; font-style: italic;">
          Set to 0 for integer formatting (only valid in "Fixed Decimal Places" mode).
        </small>
      </div>
      <br>
      <div>
        <label for="compliance-checkbox">Is Compliance:</label>
        <input type="checkbox" id="compliance-checkbox" style="margin-left: 20px;">
      </div>
      <br>
      <div>
        <label for="uncertainty-checkbox">Use Uncertainty:</label>
        <input type="checkbox" id="uncertainty-checkbox" style="margin-left: 20px;">
        <small style="display: block; margin-top: 4px; color: #6c757d; font-style: italic;">
          Show measurement uncertainty for cannabinoids (USDA hemp compliance).
        </small>
      </div>
      <br>
      <div>
        <label for="lod-display-enabled">Show LOD Column:</label>
        <input type="checkbox" id="lod-display-enabled" style="margin-left: 20px;" checked>
        <small style="display: block; margin-top: 4px; color: #6c757d; font-style: italic;">
          Display Limit of Detection (LOD) column. When disabled, no results will show as "ND" (Not Detected).
        </small>
      </div>
      <br>
      <div>
        <label for="homogeneity-enabled">Enable Homogeneity Analysis:</label>
        <input type="checkbox" id="homogeneity-enabled" style="margin-left: 20px;">
        <small style="display: block; margin-top: 4px; color: #6c757d; font-style: italic;">
          Analyze replicate-to-replicate variation for quality control. Requires minimum number of replicates to enable.
        </small>
      </div>
      <br>
      <div>
        <label for="report-above-curve-checkbox">Report Values Above Calibration Curve:</label>
        <input type="checkbox" id="report-above-curve-checkbox" style="margin-left: 20px;">
        <small style="display: block; margin-top: 4px; color: #6c757d; font-style: italic;">
          When disabled, results exceeding the max calibrator will show as "&gt;max_value" and automatically fail compliance.
        </small>
      </div>

      {% if use_moisture_correction %}
      <div class="moisture-settings-group">
        <h4>📊 Moisture Correction - {{ assay_name|title }}</h4>
        <div style="margin-left: 20px;">
          {% if ns.moisture_found %}
          <div style="margin-bottom: 10px;">
            <strong>Moisture Content:</strong>
            <span id="moisture-value" style="color: var(--smithers-blue); font-weight: bold;">{{
              "%.2f"|format(ns.moisture_value|float) }}%</span>
            <span style="color: #28a745; margin-left: 8px;">✓ Available</span>
          </div>
          <div>
            <label for="moisture-correction-enabled">
              <input type="checkbox" id="moisture-correction-enabled" checked>
              Apply moisture correction to calculations
            </label>
          </div>
          <div>
            <label for="moisture-reporting-enabled">
              <input type="checkbox" id="moisture-reporting-enabled" checked>
              Apply moisture correction to final reporting
            </label>
          </div>
          <small style="display: block; margin-top: 8px; color: #6c757d; font-style: italic;">
            Converts results from "as-tested" to "dry weight" basis using: Result ÷ (1 - Moisture% ÷ 100)
          </small>
          {% else %}
          <div style="color: #dc3545; margin-bottom: 10px;">
            <strong>Moisture Content:</strong> ⚠️ Not Available
            <small style="display: block;">Complete moisture analysis first</small>
          </div>
          <div>
            <label for="moisture-correction-enabled">
              <input type="checkbox" id="moisture-correction-enabled" disabled>
              Apply moisture correction to calculations
            </label>
          </div>
          <div>
            <label for="moisture-reporting-enabled">
              <input type="checkbox" id="moisture-reporting-enabled" disabled>
              Apply moisture correction to final reporting
            </label>
          </div>
          {% endif %}
        </div>
      </div>
      {% endif %}

      <div>
        <label for="rsd-warning-limit">RSD Warning Limit (%):</label>
        <input type="number" id="rsd-warning-limit" min="0" max="100" step="1" value="15"
          style="margin-left: 20px; width: 80px;">
        <br><small style="margin-left: 20px; color: #666;">Yellow warning threshold for RSD values</small>
      </div>
      <div>
        <label for="rsd-fail-limit">RSD Fail Limit (%):</label>
        <input type="number" id="rsd-fail-limit" min="0" max="100" step="1" value="25"
          style="margin-left: 20px; width: 80px;">
        <br><small style="margin-left: 20px; color: #666;">Red failure threshold for RSD values</small>
      </div>
      <div>
        <label for="rsd-check-enabled">Enable RSD Checking:</label>
        <input type="checkbox" id="rsd-check-enabled" style="margin-left: 20px;" checked>
        <br><small style="margin-left: 20px; color: #666;">Show RSD status indicators and color coding</small>
      </div>

      <div>
        <button id="restore-batch-data-btn">Restore Batch Data</button>
        <button id="generate-final-results-btn" style="margin-left: 10px;">Generate Final Results</button>
        <button id="view-final-results-btn" style="margin-left: 10px;">View Final Results</button>
      </div>

      <div class="legend-section">
        <h4>📊 Visual Indicators Legend</h4>
        <div class="legend-grid">
          <div>
            <strong>Status Icons:</strong>
            <span class="status-icon pass">✓</span> Pass<br>
            <span class="status-icon fail">✗</span> Fail<br>
            <span class="status-icon warning">⚠</span> Warning<br>
            <span class="status-icon unknown">–</span> Unknown<br>
            🌿 Moisture Corrected (Dry Weight)
          </div>
          <div>
            <strong>Result Types:</strong>
            <span class="result-nt" style="padding: 2px 6px;">NT</span> Not Tested<br>
            <span class="result-nd" style="padding: 2px 6px;">ND</span> Not Detected<br>
            <span class="result-loq" style="padding: 2px 6px;">&lt;LOQ</span> Below LOQ<br>
            <span class="result-above-curve" style="padding: 2px 6px;">&gt;Max</span> Above Curve
          </div>
          <div>
            <strong>RSD Status:</strong>
            <span class="rsd-pass" style="padding: 2px 6px;">Good</span> ≤ Warning Limit<br>
            <span class="rsd-warning" style="padding: 2px 6px;">Caution</span> Warning-Fail Range<br>
            <span class="rsd-fail" style="padding: 2px 6px;">Poor</span> > Fail Limit
          </div>
          <div>
            <strong>Quality Control:</strong>
            <span class="limit-warning" style="padding: 2px 6px;">Near Limit</span> > 80% of limit<br>
            <span class="critical-value" style="padding: 2px 6px;">Critical</span> > 95% of limit<br>
            <span class="loq-qc-warning" style="padding: 2px 6px;">QC Warning</span> LOQ > Action Limit
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Homogeneity Tab -->
  <div class="ws-tab-content ws-tab-container" id="ws-tab-homogeneity" style="display:none">
    <h2>Homogeneity Analysis</h2>
    <p style="margin-bottom: 20px; color: #666;">
      Evaluates replicate-to-replicate variation within each analyte.
      Homogeneity is calculated as (individual_value - mean_value) / mean_value for each test.
    </p>

    <div id="homogeneity-content">
      <!-- Homogeneity Analysis Table -->
      <div id="homogeneity-table-container" style="display: none;">
        <table>
          <thead>
            <tr>
              <th style="position: sticky; left: 0; background: white; z-index: 10;">Analyte</th>
              <th><input type="checkbox" class="ws-homogeneity-include-all" name="ws_homogeneity_include_all"
                  title="Include/exclude all analytes in homogeneity analysis"></th>
              <th>Mean</th>
              <th>Homogeneity Value</th>
              <th>Limit</th>
              <th>Status</th>
              {% for t in tests %}
              <th>Test {{ t.id }}</th>
              {% endfor %}
            </tr>
          </thead>
          <tbody id="homogeneity-table-body">
            {% for analyte in analytes %}
            {% set analyte_info = kvstore.get("analyte_info")[analyte] or {} %}
            {% set display_name = analyte_info.get('display_name', "") %}
            <tr data-analyte="{{ analyte }}">
              <td style="position: sticky; left: 0; background: white; font-weight: bold;">{{ display_name }}</td>
              <td><input type="checkbox" class="ws-homogeneity-include" name="ws_homogeneity_include_{{ analyte }}"
                  {{ 'checked' if analyte_info.get("homogeneity_default", false) else '' }}></td>
              <td class="hom-mean" name="hom_mean_{{ analyte }}">-</td>
              <td class="hom-value" name="hom_value_{{ analyte }}">-</td>
              <td class="hom-limit" name="hom_limit_{{ analyte }}">-</td>
              <td class="hom-status" name="hom_status_{{ analyte }}">-</td>
              {% for t in tests %}
              <td class="hom-individual" name="hom_individual_{{ analyte }}_{{ t.id }}">-</td>
              {% endfor %}
            </tr>
            {% endfor %}
          </tbody>
        </table>

        <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
          <h4 style="margin: 0 0 8px 0;">Legend:</h4>
          <div style="display: flex; gap: 20px; flex-wrap: wrap;">
            <span><strong style="color: #28a745;">PASS:</strong> Within homogeneity limits</span>
            <span><strong style="color: #dc3545;">FAIL:</strong> Exceeds homogeneity limits</span>
            <span><strong style="color: #6c757d;">N/A:</strong> Insufficient data or excluded</span>
          </div>
        </div>
      </div>

      <div id="homogeneity-placeholder">
        <p style="text-align: center; color: #999; font-style: italic;">
          Homogeneity analysis will appear here when enabled and sufficient replicates are available.
        </p>
      </div>
    </div>
  </div>

  {% for t in tests %}
  {% set test_id = t.id %}
  <div class="ws-tab-content" id="ws-tab-{{ test_id }}" style="display:none">
    <!--Test Info Table-->
    <table>
      <tr style="display:none">
        <th>Test Status</th>
        <td id="test-status">{{ t.state }}</td>
      </tr>
      <tr>
        <th>Extraction Volume (mL)</th>
        <td id="extraction-{{test_id}}">{{ t.v_ext }}</td>
      </tr>
      <tr>
        <th>Dilution Factor</th>
        <td id="dilution-{{test_id}}">{{ t.dilution }}</td>
      </tr>
      <tr>
        <th>Sample Weight (g)</th>
        <td id="weight-{{test_id}}">{{ t.testing_weight }}</td>
      </tr>
      <tr>
        <th>Inhalable Type</th>
        <td id="inhalable">{{ t.sample.inhalable}}</td>
      </tr>
    </table>

    <table>
      <thead>
        <tr>
          <th>Include <input type="checkbox" class="ws-include-all" name="ws_include_all_{{ test_id }}" checked></th>
          <th class="test-sortable" data-column="0">Analyte</th>
          <th name="instrument-header" data-column="1">Instrument Result ({{ input_unit }})</th>

          <th name="lod-header" class="test-sortable" data-column="2">LOD</th>
          <th name="loq-header" class="test-sortable" data-column="3">LOQ</th>
          <th name="final-header" class="test-sortable" data-column="4">Final Result ({{ current_display_unit }})</th>
          <th name="limit-header" class="test-sortable ws-compliance-column" data-column="5">Limit ({{
            current_display_unit }})</th>
          <th class="sortable ws-compliance-column" data-column="6">Status</th>
        </tr>
      </thead>
      <tbody id="analyte-body">
        {% for analyte in analytes %}
        {% set analyte_info = kvstore.get("analyte_info")[analyte] or {} %}
        {% set limit_key = 'action_limit_inhaled' if t.sample.inhalable == 'Inhaled' else 'action_limit_ingested' %}
        {% set limit = analyte_info.get(limit_key) %}
        {% if limit is none %}
        {% set limit = analyte_info.get('action_limit') %}
        {% endif %}
        {% set lod = analyte_info.get('lod_in_vial') %}
        {% set loq = analyte_info.get('loq_in_vial') %}
        {% set display_name = analyte_info.get('display_name') %}
        <tr data-ws-analyte="{{ analyte }}" data-ws-test="{{ test_id }}">
          <td>
            <input type="checkbox" class="ws-include" name="ws_include_{{ analyte }}_{{ test_id }}" checked>
          </td>
          <td>{{ display_name }}</td>
          <td>
            <input type="number" class="ws-instrument" name="ws_instrument_{{ analyte }}_{{ test_id }}">
          </td>

          <td class="ws-lod" id="ws_lod_{{ analyte }}_{{ test_id }}" data-ws-raw="{{ lod }}">-</td>
          <td class="ws-loq" id="ws_loq_{{ analyte }}_{{ test_id }}" data-ws-raw="{{ loq }}">-</td>
          <td class="ws-final" name="ws_final_{{ analyte }}_{{ test_id }}">NT</td>
          <td class="ws-limit ws-compliance-column" id="ws_limit_{{analyte}}_{{test_id}}"
            data-ws-raw="{{ limit or 0 }}">-</td>
          <td class="ws-status ws-compliance-column" name="ws_status_{{ analyte }}_{{ test_id }}">-</td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
  {% endfor %}

  <!-- Data Deviation Modal -->
  <div id="deviation-modal" class="deviation-modal">
    <div class="deviation-modal-content">
      <span class="deviation-close">&times;</span>
      <h3 style="color: #dc3545; margin-top: 0;">🔒 Data Integrity Deviation Request</h3>
      <p><strong>Warning:</strong> You are requesting permission to modify instrument data or analyte inclusion
        settings. This action requires proper documentation and justification.</p>

      <form class="deviation-form" id="deviation-form">
        <label for="analyst-name">Analyst Name:</label>
        <input type="text" id="analyst-name" required>

        <label for="deviation-reason">Reason for Data Modification:</label>
        <select id="deviation-reason" required>
          <option value="">Select a reason...</option>
          <optgroup label="Instrument Data Changes">
            <option value="instrument_malfunction">Instrument Malfunction</option>
            <option value="export_failure">Data Export Failure</option>
            <option value="integration_error">Integration Error</option>
            <option value="peak_manual_integration">Manual Peak Integration Required</option>
          </optgroup>
          <optgroup label="Analyte Inclusion Changes">
            <option value="analyte_interference">Analyte Interference Detected</option>
            <option value="sample_contamination">Sample Contamination</option>
            <option value="matrix_effect">Severe Matrix Effect</option>
            <option value="qc_failure">QC Criteria Not Met</option>
            <option value="analytical_issue">Analytical Method Issue</option>
          </optgroup>
          <optgroup label="Other">
            <option value="final_review_update">Final Review Update</option>
            <option value="other">Other (specify below)</option>
          </optgroup>
        </select>

        <label for="deviation-description">Detailed Description:</label>
        <textarea id="deviation-description"
          placeholder="Provide detailed explanation of the issue and why manual data entry or analyte exclusion is necessary. Include scientific justification, QC impact assessment, and any corrective actions taken..."
          required></textarea>

        <div style="text-align: right; margin-top: 20px;">
          <button type="button" id="cancel-deviation">Cancel</button>
          <button type="submit" style="background-color: #ffc107; margin-left: 10px;">Log Deviation & Unlock</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Deviation Review Modal -->
  <div id="deviation-review-modal" class="deviation-modal">
    <div class="deviation-modal-content" style="max-width: 900px; width: 90%;">
      <span class="deviation-review-close">&times;</span>
      <h3 style="color: #17a2b8; margin-top: 0;">📋 Data Integrity Deviation Review</h3>
      <p>Review all logged data integrity deviations for quality assurance and audit purposes.</p>

      <div id="deviation-review-content">
        <!-- Content will be populated dynamically -->
      </div>

      <div style="text-align: right; margin-top: 20px;">
        <button type="button" id="export-deviations-btn"
          style="background-color: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px;">📥
          Export Deviations</button>
        <button type="button" id="close-deviation-review">Close</button>
      </div>
    </div>
  </div>

  <!-- Confident Cannabis Integration Fields -->
  <!-- These fields are populated by JavaScript but must be declared in the template for API access -->
  {% for analyte in analytes %}
  {% set cc_result_name = "{}_cc_result".format(analyte) %}
  {% set cc_lod_name = "{}_cc_lod".format(analyte) %}
  {% set cc_loq_name = "{}_cc_loq".format(analyte) %}
  {% set cc_limit_name = "{}_cc_action_limit".format(analyte) %}
  {% set cc_homogeneity_name = "{}_cc_homogeneity_pass".format(analyte) %}
  __(input, {{cc_result_name}}, html_style="display:none;")__
  __(input, {{cc_lod_name}}, html_style="display:none;")__
  __(input, {{cc_loq_name}}, html_style="display:none;")__
  __(input, {{cc_limit_name}}, html_style="display:none;")__
  __(input, {{cc_homogeneity_name}}, html_style="display:none;")__
  {% endfor %}

  <!-- CC Export Metadata Field -->
  __(textarea, cc_export_metadata, html_style="display:none;")__

  <!-- Overall Homogeneity Pass/Fail Field -->
  __(input, cc_overall_homogeneity_pass, html_style="display:none;")__
  __(input, homogeneity_cc_action_limit, html_style="display:none;")__

  <script>

    // Per-instance isolation wrapper: scope all selectors to this worksheet's container
    (function initQBenchWorksheetInstance() {
      // NOTE: In some preview/eval environments, currentScript can be null and DOM may not be ready yet.
      const __SCRIPT__ = window.document.currentScript || null;
      console.log('[WS] init: currentScript =', __SCRIPT__);
      let __WS_CONTAINER__ = null;

      function tryResolveContainer(reason) {
        if (__WS_CONTAINER__) return __WS_CONTAINER__;
        const from = reason ? `[${reason}]` : '';
        // Try via currentScript.closest
        if (__SCRIPT__) {
          const viaClosest = __SCRIPT__.closest('.qbench-worksheet-container');
          if (viaClosest) {
            __WS_CONTAINER__ = viaClosest;
            console.log('[WS]', from, 'resolved via closest:', __WS_CONTAINER__);
          }
          if (!__WS_CONTAINER__) {
            const candidates = window.document.querySelectorAll('.qbench-worksheet-container');
            console.log('[WS]', from, 'candidates length =', candidates.length);
            for (const c of candidates) {
              if (c.contains(__SCRIPT__)) { __WS_CONTAINER__ = c; break; }
            }
            if (__WS_CONTAINER__) console.log('[WS]', from, 'resolved via contains():', __WS_CONTAINER__);
          }
        }
        // Fallback: first uninitialized or last container
        if (!__WS_CONTAINER__) {
          const all = Array.from(window.document.querySelectorAll('.qbench-worksheet-container'));
          if (all.length) {
            const pick = all.find(c => !c.hasAttribute('data-ws-initialized')) || all.at(-1);
            if (pick) {
              __WS_CONTAINER__ = pick;
              __WS_CONTAINER__.setAttribute('data-ws-initialized', 'true');
              console.log('[WS]', from, 'picked fallback container id/index =', __WS_CONTAINER__.id || '(no id)', all.indexOf(__WS_CONTAINER__));
            }
          }
        }
        return __WS_CONTAINER__;
      }

      // Initial attempt
      tryResolveContainer('init');

      // If still not available, set up retries (DOMContentLoaded, rAF ticks, and MutationObserver)
      if (!__WS_CONTAINER__) {
        console.warn('[WS] container not found at init; installing waiters');
        // DOMContentLoaded
        window.document.addEventListener('DOMContentLoaded', () => {
          tryResolveContainer('DOMContentLoaded');
        }, { once: true });
        // rAF retries (3 frames)
        let rafTries = 3;
        (function tick() {
          if (__WS_CONTAINER__ || rafTries-- <= 0) return;
          requestAnimationFrame(() => { tryResolveContainer('rAF'); tick(); });
        })();
        // MutationObserver
        const mo = new MutationObserver(() => {
          if (tryResolveContainer('MO')) mo.disconnect();
        });
        if (window.document.body) {
          mo.observe(window.document.body, { childList: true, subtree: true });
        } else {
          window.addEventListener('load', () => {
            if (window.document.body) mo.observe(window.document.body, { childList: true, subtree: true });
          });
        }
      }

      // Scoped document proxy: transparently limit document.* queries to this container when available
      const document = new Proxy(window.document, {
        get(target, prop, receiver) {
          if (prop === 'querySelector') {
            return (...args) => (__WS_CONTAINER__ || target).querySelector.apply((__WS_CONTAINER__ || target), args);
          }
          if (prop === 'querySelectorAll') {
            return (...args) => (__WS_CONTAINER__ || target).querySelectorAll.apply((__WS_CONTAINER__ || target), args);
          }
          if (prop === 'getElementById') {
            return (id) => (__WS_CONTAINER__ || target).querySelector('#' + (window.CSS?.escape ? CSS.escape(id) : id));
          }
          if (prop === 'getElementsByName') {
            return (name) => (__WS_CONTAINER__ || target).querySelectorAll('[name="' + (window.CSS?.escape ? CSS.escape(name) : name) + '"]');
          }
          // Fall back to the real document for everything else; bind functions to real document
          try {
            const val = target[prop];
            return typeof val === 'function' ? val.bind(target) : val;
          } catch (e) {
            console.warn('[WS] proxy get failed for', String(prop), e);
            const val2 = window.document[prop];
            return typeof val2 === 'function' ? val2.bind(window.document) : val2;
          }
        }
      });

      // QBench Worksheet Scoping Helper - Find elements within THIS worksheet instance only
      function getWorksheetContainer() {
        return __WS_CONTAINER__;
      }

      function getElement(selector) {
        const container = getWorksheetContainer();
        return container ? container.querySelector(selector) : document.querySelector(selector);
      }

      function getElements(selector) {
        const container = getWorksheetContainer();
        return container ? container.querySelectorAll(selector) : document.querySelectorAll(selector);
      }

      function getElementById(id) {
        const container = getWorksheetContainer();
        return container ? container.querySelector(`#${id}`) : document.getElementById(id);
      }

      function getElementsByName(name) {
        const container = getWorksheetContainer();
        return container ? container.querySelectorAll(`[name="${name}"]`) : document.getElementsByName(name);
      }

      const wsScaling = {
        'ppb': 1,
        'ng/mL': 1,
        'µg/mL': 1e3,
        'µg': 1e3,
        'ppm': 1e3,
        '%': 1e7,
        'cfu/g': 1,
        'mg/g': 1e6,
        'mg/mL': 1e6,
        // Note: mg/serving and mg/package are handled specially in wsConvertWithSample
      };

      function wsConvert(value, from, to) {
        if (!(from in wsScaling) || !(to in wsScaling)) return value;

        // PPB-normalized approach: convert through ppb for consistency
        if (from === to) return value;

        // Convert to ppb first
        const ppbValue = value * (wsScaling[from] / wsScaling['ppb']);

        // Convert from ppb to target unit
        return ppbValue * (wsScaling['ppb'] / wsScaling[to]);
      }

      // Enhanced conversion function that handles special units requiring sample metadata
      function wsConvertWithSample(value, fromUnit, toUnit, sampleMetadata = {}) {
        // Handle special units that require sample metadata
        if (toUnit === 'mg/serving' || toUnit === 'mg/package') {
          // First normalize to ppb
          const ppbValue = wsConvert(value, fromUnit, 'ppb');

          // Convert ppb to mg/g as base concentration
          const mgPerG = ppbValue / 1000000;  // 1,000,000 ppb = 1 mg/g

          if (toUnit === 'mg/serving') {
            const servingWeight = sampleMetadata.serving_weight || 1;
            return mgPerG * servingWeight;
          }

          if (toUnit === 'mg/package') {
            const servingWeight = sampleMetadata.serving_weight || 1;
            const servingsPerPackage = sampleMetadata.servings_per_package || 1;
            return mgPerG * servingWeight * servingsPerPackage;
          }
        }

        // Handle conversion FROM special units back to regular units
        if (fromUnit === 'mg/serving') {
          const servingWeight = sampleMetadata.serving_weight || 1;
          const mgPerG = value / servingWeight;  // Back to mg/g
          const ppbValue = mgPerG * 1000000;     // mg/g to ppb
          return wsConvert(ppbValue, 'ppb', toUnit);
        }

        if (fromUnit === 'mg/package') {
          const servingWeight = sampleMetadata.serving_weight || 1;
          const servingsPerPackage = sampleMetadata.servings_per_package || 1;
          const mgPerG = value / (servingWeight * servingsPerPackage);  // Back to mg/g
          const ppbValue = mgPerG * 1000000;     // mg/g to ppb
          return wsConvert(ppbValue, 'ppb', toUnit);
        }

        // For regular unit conversions, use the standard function
        return wsConvert(value, fromUnit, toUnit);
      }

      // Moisture Correction Functions
      function applyMoistureCorrection(value, moisturePercent) {
        // Formula: Corrected Result = Raw Result ÷ (1 - Moisture% ÷ 100)
        // This converts from "as-tested" to "dry weight" basis
        if (!moisturePercent || moisturePercent <= 0 || moisturePercent >= 100) {
          return value; // No correction if moisture is invalid
        }
        return value / (1 - (moisturePercent / 100));
      }

      function getMoistureSettings() {
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");

        // Get checkbox states, but only auto-apply if use_moisture_correction is enabled
        const useMoistureCorrection = wsUnitConfig.use_moisture_correction || false;
        const moistureFound = wsUnitConfig.moisture_found || false;
        const moistureValid = moistureFound && wsUnitConfig.moisture_value > 0 && wsUnitConfig.moisture_value < 100;

        const correctionCheckbox = getElementById("moisture-correction-enabled");
        const reportingCheckbox = getElementById("moisture-reporting-enabled");

        // Only apply correction if use_moisture_correction is explicitly enabled
        const correctionEnabled = useMoistureCorrection && (correctionCheckbox ?
          correctionCheckbox.checked :
          (moistureValid));

        const reportingEnabled = useMoistureCorrection && (reportingCheckbox ?
          reportingCheckbox.checked :
          (moistureValid));

        return {
          useMoistureCorrection: useMoistureCorrection,
          moistureValue: wsUnitConfig.moisture_value || 0,
          moistureFound: moistureFound,
          correctionEnabled: correctionEnabled,
          reportingEnabled: reportingEnabled,
          assayName: wsUnitConfig.assay_name || ''
        };
      }

      function updateMoistureDisplay() {
        const moistureSettings = getMoistureSettings();
        const moistureValueElement = getElementById("moisture-value");

        if (moistureValueElement && moistureSettings.moistureFound) {
          moistureValueElement.textContent = `${parseFloat(moistureSettings.moistureValue).toFixed(2)}%`;
        }

        // Log moisture correction status for debugging
        if (moistureSettings.useMoistureCorrection && moistureSettings.moistureFound) {
          const moistureValid = moistureSettings.moistureValue > 0 && moistureSettings.moistureValue < 100;
          if (moistureValid) {
            console.log(`Moisture correction available: ${parseFloat(moistureSettings.moistureValue).toFixed(2)}% from ${moistureSettings.assayName}`);
            if (moistureSettings.correctionEnabled) {
              console.log("✓ Moisture correction applied to calculations");
            }
            if (moistureSettings.reportingEnabled) {
              console.log("✓ Moisture correction applied to final reporting");
            }
          } else {
            console.log("⚠️ Moisture value invalid:", moistureSettings.moistureValue);
          }
        }
      }

      /**
       * Calculate synthetic analyte LOD/LOQ values based on configured mode
       * @param {string} analyte - The analyte name
       * @param {string} testId - The test ID
       * @param {string} type - Either 'lod' or 'loq'
       * @returns {number} - The calculated LOD/LOQ value
       */
      function calculateSyntheticLodLoq(analyte, testId, type) {
        const analyteInfo = JSON.parse(getElementById("ws-analyte-info")?.textContent || "{}");
        const isomersMap = JSON.parse(getElementById("ws-isomers-map")?.textContent || "{}");

        const analyteConfig = analyteInfo[analyte];
        if (!analyteConfig) return 0;

        // Get the synthetic LOD mode - default to standard behavior if not specified
        const syntheticMode = analyteConfig.synthetic_lod_mode;
        if (!syntheticMode || !isomersMap[analyte]) {
          // Not a synthetic analyte or no special mode - return the configured value
          return parseFloat(analyteConfig[`${type}_in_vial`]) || 0;
        }

        const components = isomersMap[analyte];
        if (!components || components.length === 0) {
          return parseFloat(analyteConfig[`${type}_in_vial`]) || 0;
        }

        switch (syntheticMode) {
          case 'zero':
            // Always return 0 for synthetic analytes in zero mode
            return 0;

          case 'composite':
            // Use the lowest component LOD/LOQ value
            let minValue = Infinity;
            for (const component of components) {
              const compConfig = analyteInfo[component.analyte];
              if (compConfig) {
                const compValue = parseFloat(compConfig[`${type}_in_vial`]) || 0;
                minValue = Math.min(minValue, compValue);
              }
            }
            return minValue === Infinity ? 0 : minValue;

          case 'additive':
            // Sum all component LOD/LOQ values (weighted by factor)
            let totalValue = 0;
            for (const component of components) {
              const compConfig = analyteInfo[component.analyte];
              if (compConfig) {
                const compValue = parseFloat(compConfig[`${type}_in_vial`]) || 0;
                const factor = parseFloat(component.factor) || 1;
                totalValue += compValue * factor;
              }
            }
            return totalValue;

          default:
            // Unknown mode - fall back to configured value
            return parseFloat(analyteConfig[`${type}_in_vial`]) || 0;
        }
      }

      /**
       * Check if a synthetic analyte result should be ND/<LOQ based on its calculated LOD/LOQ
       * @param {number} calculatedResult - The calculated result value
       * @param {string} analyte - The analyte name
       * @param {string} testId - The test ID
       * @param {string} displayUnit - The current display unit
       * @returns {string|null} - Returns "ND", "<LOQ", or null if numeric result should be shown
       */
      function checkSyntheticAnalyteStatus(calculatedResult, analyte, testId, displayUnit) {
        const analyteInfo = JSON.parse(getElementById("ws-analyte-info")?.textContent || "{}");
        const isomersMap = JSON.parse(getElementById("ws-isomers-map")?.textContent || "{}");
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");

        const analyteConfig = analyteInfo[analyte];
        if (!analyteConfig || !analyteConfig.synthetic_lod_mode || !isomersMap[analyte]) {
          return null; // Not a synthetic analyte with LOD mode
        }

        // Only apply ND/<LOQ logic for modes that should have detectable thresholds
        if (analyteConfig.synthetic_lod_mode === 'zero') {
          return null; // Zero mode always shows numeric results
        }

        // Calculate the LOD/LOQ thresholds in the display unit
        const lodRaw = calculateSyntheticLodLoq(analyte, testId, 'lod');
        const loqRaw = calculateSyntheticLodLoq(analyte, testId, 'loq');

        // Convert to display units (similar to how individual tests do it)
        // Get sample factors for this test
        const ext = parseFloat(getElementById(`ws_extraction_${testId}`)?.value) || 1;
        const dil = parseFloat(getElementById(`ws_dilution_${testId}`)?.value) || 1;
        const wt = parseFloat(getElementById(`ws_weight_${testId}`)?.value) || 1;

        const lodThreshold = wsConvert(lodRaw, wsUnitConfig.input_unit, displayUnit) * ext * dil / wt;
        const loqThreshold = wsConvert(loqRaw, wsUnitConfig.input_unit, displayUnit) * ext * dil / wt;

        // Apply moisture correction if enabled
        const moistureSettings = getMoistureSettings();
        if (moistureSettings.useMoistureCorrection && moistureSettings.correctionEnabled && moistureSettings.moistureFound && moistureSettings.moistureValue > 0) {
          const correctedLodThreshold = applyMoistureCorrection(lodThreshold, moistureSettings.moistureValue);
          const correctedLoqThreshold = applyMoistureCorrection(loqThreshold, moistureSettings.moistureValue);

          // Check thresholds
          if (calculatedResult < correctedLodThreshold && isLodDisplayEnabled()) {
            return "ND";
          } else if (calculatedResult < correctedLoqThreshold) {
            return "<LOQ";
          }
        } else {
          // Check thresholds without moisture correction
          if (calculatedResult < lodThreshold && isLodDisplayEnabled()) {
            return "ND";
          } else if (calculatedResult < loqThreshold) {
            return "<LOQ";
          }
        }

        return null; // Show numeric result
      }

      function wsRecalculate(testId, analyte) {
        const liveField = getLiveField();
        const wsUpdatedData = JSON.parse(liveField?.value || "{}");
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const isomersMap = JSON.parse(getElementById("ws-isomers-map")?.textContent || "{}");
        const displayUnit = getCurrentDisplayUnit();
        const sigFigsInput = getElementById("sig-fig-input")?.value;
        const sigFigs = sigFigsInput !== '' && sigFigsInput !== null ? parseInt(sigFigsInput) : 3;

        const row = getElement(`tr[data-ws-analyte="${analyte}"][data-ws-test="${testId}"]`);
        if (!row) return;

        const input = row.querySelector('.ws-instrument');

        // Extract sample metadata
        const ext = parseFloat(getElementById(`extraction-${testId}`)?.textContent) || 1;
        const dil = parseFloat(getElementById(`dilution-${testId}`)?.textContent) || 1;
        const wt = parseFloat(getElementById(`weight-${testId}`)?.textContent) || 1;

        // Handle synthetic analytes (e.g., total_thc, total_cannabinoids)
        let raw = 0;
        let displayedRaw = 0;
        let isSynthetic = false;
        if (isomersMap[analyte]) {
          isSynthetic = true;
          raw = isomersMap[analyte].reduce((sum, { analyte: sub, factor }) => {
            const subCheckbox = getElement(`input[name="ws_include_${sub}_${testId}"]`);
            if (subCheckbox && subCheckbox.checked) {
              const subInput = getElement(`input[name="ws_instrument_${sub}_${testId}"]`);
              const subVal = parseFloat(subInput?.value) || 0;
              return sum + subVal * factor;
            }
            else { return sum; }
          }, 0);

          // Store the displayed (rounded) value for traditional calculations
          const strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
          if (strategy === "significant_figures") {
            displayedRaw = parseFloat(formatToSigFigs(raw, sigFigs));
          } else {
            displayedRaw = parseFloat(raw.toFixed(sigFigs));
          }

          if (input) {
            if (strategy === "significant_figures") {
              input.value = formatToSigFigs(raw, sigFigs);
            } else {
              input.value = raw.toFixed(sigFigs);
            }
            input.disabled = true;
          }
        } else {
          raw = parseFloat(input?.value) || 0;
          displayedRaw = raw; // For non-synthetic analytes, raw and displayed are the same
        }

        // Convert and calculate display values
        let scaledRaw = wsConvert(raw, wsUnitConfig.input_unit, displayUnit) * ext * dil / wt;

        // Calculate LOD/LOQ using synthetic modes if applicable
        let lodRaw = calculateSyntheticLodLoq(analyte, testId, 'lod');
        let loqRaw = calculateSyntheticLodLoq(analyte, testId, 'loq');

        let lod = wsConvert(lodRaw, wsUnitConfig.input_unit, displayUnit) * ext * dil / wt;
        let loq = wsConvert(loqRaw, wsUnitConfig.input_unit, displayUnit) * ext * dil / wt;
        const limit = wsConvert(parseFloat(row.querySelector('.ws-limit')?.dataset.wsRaw) || 0, wsUnitConfig.limit_unit, displayUnit);

        // Apply moisture correction if enabled
        const moistureSettings = getMoistureSettings();
        if (moistureSettings.useMoistureCorrection && moistureSettings.correctionEnabled && moistureSettings.moistureFound && moistureSettings.moistureValue > 0) {
          // Apply moisture correction to results, LOD, and LOQ (but not limits)
          scaledRaw = applyMoistureCorrection(scaledRaw, moistureSettings.moistureValue);
          lod = applyMoistureCorrection(lod, moistureSettings.moistureValue);
          loq = applyMoistureCorrection(loq, moistureSettings.moistureValue);
        }

        // Check if value exceeds max calibrator
        const analyteInfo = JSON.parse(getElementById("ws-analyte-info")?.textContent || "{}");
        const analyteConfig = analyteInfo[analyte];
        const maxCalibratorRaw = analyteConfig?.max_calibrator; // In instrument units (ppb)

        let exceedsMaxCalibrator = false;
        let maxCalibratorDisplay = null;
        if (maxCalibratorRaw && maxCalibratorRaw > 0) {
          // Convert max calibrator to display units
          maxCalibratorDisplay = wsConvert(maxCalibratorRaw, wsUnitConfig.input_unit, displayUnit) * ext * dil / wt;
          
          // Apply moisture correction to max if needed
          if (moistureSettings.useMoistureCorrection && moistureSettings.correctionEnabled && moistureSettings.moistureFound && moistureSettings.moistureValue > 0) {
            maxCalibratorDisplay = applyMoistureCorrection(maxCalibratorDisplay, moistureSettings.moistureValue);
          }
          
          exceedsMaxCalibrator = scaledRaw > maxCalibratorDisplay;
        }

        // Update table cells
        const strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
        row.querySelector('.ws-lod').textContent = applyNumberFormatting(lod, sigFigs, strategy);
        row.querySelector('.ws-loq').textContent = applyNumberFormatting(loq, sigFigs, strategy);

        // Only show limits if compliance mode is enabled
        if (isComplianceMode()) {
          row.querySelector('.ws-limit').textContent = limit > 0 ? applyNumberFormatting(limit, sigFigs, strategy) : "-";
        } else {
          row.querySelector('.ws-limit').textContent = "-";
        }

        // QC Check: LOQ vs Action Limit
        const loqCell = row.querySelector('.ws-lod');
        const loqCellLOQ = row.querySelector('.ws-loq');
        let qcStatus = null;

        // Remove previous QC warning classes
        loqCell.classList.remove('loq-qc-warning');
        loqCellLOQ.classList.remove('loq-qc-warning');

        if (limit > 0 && loq > limit) {
          // Critical QC issue: LOQ exceeds action limit
          loqCellLOQ.classList.add('loq-qc-warning');
          loqCellLOQ.title = `QC WARNING: LOQ (${loq.toFixed(sigFigs)}) exceeds action limit (${limit.toFixed(sigFigs)}). Method detection capability insufficient for required limit.`;
          qcStatus = "QC-Warning";
          console.warn(`QC Issue - ${analyte}: LOQ (${loq.toFixed(sigFigs)}) > Limit (${limit.toFixed(sigFigs)})`);
        }

        let resultDisplay = "-";
        let moistureIndicator = "";

        // Add moisture correction indicator if applied
        if (moistureSettings.useMoistureCorrection && moistureSettings.correctionEnabled && moistureSettings.moistureFound && moistureSettings.moistureValue > 0) {
          moistureIndicator = " 🌿"; // Dry weight indicator
        }

        // Calculate and display results for all selected units
        const selectedUnits = getSelectedOutputUnits();
        const sampleInfo = JSON.parse(getElementById("ws-sample-info")?.textContent || "{}");

        selectedUnits.forEach(unit => {
          // Prepare sample metadata for special unit conversions
          const sampleMetadata = {
            serving_weight: sampleInfo.serving_weight || 1,
            servings_per_package: sampleInfo.servings_per_package || 1
          };

          // Get the appropriate raw value based on number format strategy
          const strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
          const strategyRawValue = getValueForStrategy(raw, sigFigs, strategy);

          // Convert appropriate raw value to this specific unit using enhanced conversion
          const baseFinalValue = strategyRawValue * ext * dil / wt;
          let unitScaledRaw = wsConvertWithSample(baseFinalValue, wsUnitConfig.input_unit, unit, sampleMetadata);

          // Apply moisture correction if enabled for this unit
          if (moistureSettings.useMoistureCorrection && moistureSettings.correctionEnabled && moistureSettings.moistureFound && moistureSettings.moistureValue > 0) {
            unitScaledRaw = applyMoistureCorrection(unitScaledRaw, moistureSettings.moistureValue);
          }

          // Determine result display for this unit using strategy-aware number formatting
          let unitResultDisplay = "-";

          // Check user preference for reporting above curve
          const reportAboveCurve = getElementById("report-above-curve-checkbox")?.checked || false;

          if (input.value === '' && !isSynthetic) {
            unitResultDisplay = "NT";
          } else if (exceedsMaxCalibrator && !reportAboveCurve) {
            // Show ">max" instead of numeric value when exceeds calibrator and reporting disabled
            // Calculate max for this specific unit
            const unitMaxCalibrator = wsConvertWithSample(maxCalibratorRaw * ext * dil / wt, wsUnitConfig.input_unit, unit, sampleMetadata);
            
            // Apply moisture correction if needed
            const adjustedUnitMax = (moistureSettings.useMoistureCorrection && moistureSettings.correctionEnabled && moistureSettings.moistureFound && moistureSettings.moistureValue > 0)
              ? applyMoistureCorrection(unitMaxCalibrator, moistureSettings.moistureValue)
              : unitMaxCalibrator;
            
            unitResultDisplay = `>${applyNumberFormatting(adjustedUnitMax, sigFigs, strategy)}`;
          } else {
            const formattedValue = applyNumberFormatting(unitScaledRaw, sigFigs, strategy);
            unitResultDisplay = formattedValue + moistureIndicator;
          }

          // Set the main resultDisplay for the current display unit (for legacy compatibility)
          if (unit === displayUnit) {
            resultDisplay = unitResultDisplay;
          }

          // Find and update the final result cell for this unit
          const finalCell = row.querySelector(`[name="ws_final_${analyte}_${testId}_${unit}"]`);
          if (finalCell) {
            finalCell.textContent = unitResultDisplay;

            // Apply result type styling to each cell
            finalCell.classList.remove('result-nt', 'result-nd', 'result-loq', 'result-normal', 'result-above-curve', 'limit-warning', 'critical-value');
            finalCell.classList.add(getResultTypeClass(unitResultDisplay));
            
            // Add above-curve styling if applicable
            if (exceedsMaxCalibrator && !reportAboveCurve) {
              finalCell.classList.add('result-above-curve');
            }
          }
        });

        // Update the old .ws-final cell for backward compatibility (using display unit)
        const legacyFinalCell = row.querySelector('.ws-final:not([data-unit])');
        if (legacyFinalCell) {
          legacyFinalCell.textContent = resultDisplay;
          legacyFinalCell.classList.remove('result-nt', 'result-nd', 'result-loq', 'result-normal', 'result-above-curve', 'limit-warning', 'critical-value');
          legacyFinalCell.classList.add(getResultTypeClass(resultDisplay));
          
          // Add above-curve styling if applicable
          if (exceedsMaxCalibrator && !reportAboveCurve) {
            legacyFinalCell.classList.add('result-above-curve');
          }
        }

        // Enhanced status display with styling for individual tests
        const statusCell = row.querySelector('.ws-status');
        let statusText = "–";

        // Only show Pass/Fail if compliance mode is enabled
        if (isComplianceMode()) {
          // Check user preference for reporting above curve
          const reportAboveCurve = getElementById("report-above-curve-checkbox")?.checked || false;
          
          if (exceedsMaxCalibrator && !reportAboveCurve) {
            // Automatic fail if exceeds calibration curve
            statusText = "Fail";
            statusCell.title = "Result exceeds maximum calibrator - outside calibration range";
          } else {
            let valueForComparison = scaledRaw;

            // If uncertainty mode is enabled, use (value - uncertainty) for pass/fail determination
            if (isUncertaintyMode() && wsUnitConfig.uncertainty_data && wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`]) {
              const uncertaintyPercent = wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`];
              const uncertaintyValue = scaledRaw * uncertaintyPercent / 100;
              valueForComparison = scaledRaw - uncertaintyValue;
            }

            statusText = (limit > 0 && scaledRaw >= 0) ? (valueForComparison <= limit ? "Pass" : "Fail") : "–";

            // Override status if QC issue detected
            if (qcStatus === "QC-Warning") {
              statusText = "Warning";
            }
          }
        }

        statusCell.innerHTML = `${getStatusIcon(statusText)}${statusText}`;
        applyStatusStyling(statusCell, statusText);

        // Add limit warnings for individual tests
        if (limit > 0 && statusText === 'Pass' && !isNaN(scaledRaw) && legacyFinalCell) {
          let valueForRatio = scaledRaw;

          // If uncertainty mode is enabled, use (value - uncertainty) for critical value warnings
          if (isUncertaintyMode() && wsUnitConfig.uncertainty_data && wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`]) {
            const uncertaintyPercent = wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`];
            const uncertaintyValue = scaledRaw * uncertaintyPercent / 100;
            valueForRatio = scaledRaw - uncertaintyValue;
          }

          const ratio = valueForRatio / limit;
          if (ratio > 0.95) {
            // Critical values get red styling and pulse animation
            legacyFinalCell.classList.add('critical-value');
          } else if (ratio > 0.8) {
            // Warning values get yellow styling
            legacyFinalCell.classList.add('limit-warning');
          }
        }

        // Save to worksheet live JSON
        if (!wsUpdatedData[analyte]) wsUpdatedData[analyte] = {};
        wsUpdatedData[analyte][testId] = raw;

        if (liveField) liveField.value = JSON.stringify(wsUpdatedData);

        // Trigger recalculation of any dependent synthetic analytes
        Object.entries(isomersMap).forEach(([syntheticAnalyte, components]) => {
          if (components.some(c => c.analyte === analyte)) {
            wsRecalculate(testId, syntheticAnalyte);
          }
        });

      }

      function getRSDStatus(rsdValue, wsUnitConfig) {
        if (!wsUnitConfig.rsd_check_enabled || isNaN(rsdValue)) {
          return { status: 'unknown', class: '', indicator: '' };
        }

        const warningLimit = wsUnitConfig.rsd_warning_limit || 15;
        const failLimit = wsUnitConfig.rsd_fail_limit || 25;

        if (rsdValue <= warningLimit) {
          return { status: 'pass', class: 'rsd-pass', indicator: '✓' };
        } else if (rsdValue <= failLimit) {
          return { status: 'warning', class: 'rsd-warning', indicator: '⚠' };
        } else {
          return { status: 'fail', class: 'rsd-fail', indicator: '✗' };
        }
      }

      // Create detailed tooltip data for RSD diagnostics
      function createRSDTooltipData(analyte, values, mean, std, rsd, sigFigs) {
        const currentDisplayUnit = getCurrentDisplayUnit();
        const testData = [];

        // Collect individual test data
        getElements(`.ws-include[name^="ws_include_${analyte}_"]`).forEach((cb, index) => {
          if (!cb.checked) return;
          const testId = cb.name.split('_').pop();

          // Get the actual test result value
          let valueElement = getElement(`[name="ws_final_${analyte}_${testId}_${currentDisplayUnit}"]`);
          if (!valueElement) {
            valueElement = getElement(`.ws-final[name="ws_final_${analyte}_${testId}"]`);
          }

          if (valueElement && index < values.length) {
            const value = values[index];
            const deviation = value - mean;
            const deviationPercent = mean !== 0 ? (deviation / mean) * 100 : 0;

            testData.push({
              testId: testId,
              value: value,
              deviation: deviation,
              deviationPercent: deviationPercent
            });
          }
        });

        // Sort test data by value to help identify outliers
        testData.sort((a, b) => a.value - b.value);

        return {
          analyte: analyte,
          testCount: values.length,
          mean: mean,
          std: std,
          rsd: rsd,
          min: Math.min(...values),
          max: Math.max(...values),
          range: Math.max(...values) - Math.min(...values),
          testData: testData,
          unit: currentDisplayUnit,
          sigFigs: sigFigs
        };
      }

      // Add RSD diagnostic tooltip to a cell
      function addRSDTooltip(cell, tooltipData) {
        const { analyte, testCount, mean, std, rsd, min, max, range, testData, unit, sigFigs } = tooltipData;
        const strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";

        // Create detailed tooltip content
        let tooltipContent = `RSD Analysis: ${analyte}\n`;
        tooltipContent += `Statistics (${unit}):\n`;
        tooltipContent += `• Count: ${testCount} tests\n`;
        tooltipContent += `• Mean: ${applyNumberFormatting(mean, sigFigs, strategy)}\n`;
        tooltipContent += `• Std Dev: ${applyNumberFormatting(std, sigFigs, strategy)}\n`;
        tooltipContent += `• RSD: ${rsd.toFixed(2)}%\n`;
        tooltipContent += `• Min: ${applyNumberFormatting(min, sigFigs, strategy)}\n`;
        tooltipContent += `• Max: ${applyNumberFormatting(max, sigFigs, strategy)}\n`;
        tooltipContent += `• Range: ${applyNumberFormatting(range, sigFigs, strategy)}\n\n`;

        tooltipContent += `Individual Test Results:\n`;
        testData.forEach(test => {
          const deviationSign = test.deviationPercent >= 0 ? '+' : '';
          const strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
          tooltipContent += `• Test ${test.testId}: ${applyNumberFormatting(test.value, sigFigs, strategy)} (${deviationSign}${test.deviationPercent.toFixed(1)}%)\n`;
        });

        tooltipContent += `\nTip: Click on individual test tabs to investigate outliers`;

        // Set the tooltip
        cell.title = tooltipContent;

        // Add hover styling to indicate interactive content
        cell.style.cursor = 'help';
        cell.classList.add('rsd-tooltip');
      }

      function getStatusIcon(status) {
        switch (status?.toLowerCase()) {
          case 'pass':
            return '<span class="status-icon pass">✓</span>';
          case 'fail':
            return '<span class="status-icon fail">✗</span>';
          case 'warning':
            return '<span class="status-icon warning">⚠</span>';
          default:
            return '<span class="status-icon unknown"></span>';
        }
      }

      function getResultTypeClass(resultText) {
        if (resultText === 'NT') return 'result-nt';
        if (resultText === 'ND') return 'result-nd';
        if (resultText.includes('<') || resultText.includes('LOQ')) return 'result-loq';
        return 'result-normal';
      }

      function applyStatusStyling(cell, status) {
        // Remove existing status classes
        cell.classList.remove('status-pass', 'status-fail', 'status-unknown');

        // Apply appropriate status class
        switch (status?.toLowerCase()) {
          case 'pass':
            cell.classList.add('status-pass');
            break;
          case 'fail':
            cell.classList.add('status-fail');
            break;
          default:
            cell.classList.add('status-unknown');
            break;
        }
      }

      function updateOverallStatus() {
        const statusBanner = getElementById('overall-status-banner');
        const statusText = getElementById('overall-status-text');
        const complianceBadge = getElementById('overall-compliance-badge');

        if (!statusBanner || !statusText || !complianceBadge) return;

        // Count pass/fail statuses
        let passCount = 0;
        let failCount = 0;
        let warningCount = 0;
        let totalCount = 0;
        let rsdFailures = 0;
        let qcWarnings = 0;
        let hasResults = false;

        getElements('#ws-summary-body tr').forEach(row => {
          const statusCell = row.querySelector('.ws-summary-status');
          const rsdCell = row.querySelector('.ws-summary-rsd');
          const resultCell = row.querySelector('.ws-summary-mean');
          const loqCell = row.querySelector('.ws-summary-loq');

          // Check if we have actual test results (not just NT)
          if (resultCell && resultCell.textContent.trim() !== 'NT' && resultCell.textContent.trim() !== '') {
            hasResults = true;
          }

          // Check for QC warnings (LOQ > limit)
          if (loqCell && loqCell.classList.contains('loq-qc-warning')) {
            qcWarnings++;
          }

          if (statusCell && statusCell.textContent.trim() !== '-' && statusCell.textContent.trim() !== '') {
            const cleanStatus = statusCell.textContent.replace(/[✓✗⚠–]/g, '').trim();
            totalCount++;
            if (cleanStatus === 'Pass') {
              passCount++;
            } else if (cleanStatus === 'Fail') {
              failCount++;
            } else if (cleanStatus === 'Warning') {
              warningCount++;
            }
          }

          // Check for RSD failures
          if (rsdCell && rsdCell.classList.contains('rsd-fail')) {
            rsdFailures++;
          }
        });

        // Determine overall status
        let overallStatus = 'pass';
        let statusMessage = '';
        let complianceStatus = 'compliant';

        // If compliance mode is disabled, show different messaging
        if (!isComplianceMode()) {
          if (!hasResults) {
            overallStatus = 'warning';
            statusMessage = 'No test results available';
            complianceStatus = 'info';
          } else if (qcWarnings > 0) {
            overallStatus = 'warning';
            statusMessage = `QC WARNING: ${qcWarnings} analyte(s) have LOQ > action limit - method inadequate`;
            complianceStatus = 'info';
          } else if (rsdFailures > 0) {
            overallStatus = 'warning';
            statusMessage = `WARNING: ${rsdFailures} analyte(s) have poor precision (RSD > limit)`;
            complianceStatus = 'info';
          } else if (totalCount > 0) {
            overallStatus = 'pass';
            statusMessage = `Analysis complete: ${totalCount} analyte(s) tested (compliance evaluation disabled)`;
            complianceStatus = 'info';
          } else {
            overallStatus = 'pass';
            statusMessage = 'No issues detected. ';
            complianceStatus = '';
          }
        } else {
          // Normal compliance mode behavior
          if (!hasResults) {
            overallStatus = 'warning';
            statusMessage = 'No test results available';
            complianceStatus = 'pending';
          } else if (failCount > 0) {
            overallStatus = 'fail';
            statusMessage = `TEST FAIL: ${failCount} analyte(s) exceed limits`;
            complianceStatus = 'non-compliant';
          } else if (qcWarnings > 0) {
            overallStatus = 'warning';
            statusMessage = `QC WARNING: ${qcWarnings} analyte(s) have LOQ > action limit - method inadequate`;
            complianceStatus = 'pending';
          } else if (warningCount > 0) {
            overallStatus = 'warning';
            statusMessage = `WARNING: ${warningCount} analyte(s) have quality issues`;
            complianceStatus = 'pending';
          } else if (rsdFailures > 0) {
            overallStatus = 'warning';
            statusMessage = `WARNING: ${rsdFailures} analyte(s) have poor precision (RSD > limit)`;
            complianceStatus = 'pending';
          } else if (passCount > 0 || totalCount > 0) {
            overallStatus = 'pass';
            const validResults = Math.max(passCount, totalCount);
            statusMessage = `TEST PASS: All ${validResults} analyte(s) within limits`;
            complianceStatus = 'compliant';
          } else {
            overallStatus = 'warning';
            statusMessage = 'No test results available';
            complianceStatus = 'pending';
          }
        }

        // Apply moisture correction if enabled (same logic as individual tests)
        const moistureSettings = getMoistureSettings();
        if (moistureSettings.useMoistureCorrection && moistureSettings.correctionEnabled && moistureSettings.moistureFound && moistureSettings.moistureValue > 0) {
          statusMessage += 'Moisture Correction Enabled 🌿';
        }

        // Update banner
        statusBanner.className = `overall-status-banner ${overallStatus}`;
        statusText.innerHTML = `${getStatusIcon(overallStatus)} ${statusMessage}`;

        // Update compliance badge
        complianceBadge.className = `compliance-badge ${complianceStatus}`;
        if (complianceStatus === 'info') {
          complianceBadge.textContent = 'Info';
        } else {
          complianceBadge.textContent = complianceStatus.charAt(0).toUpperCase() + complianceStatus.slice(1);
        }
      }


      // Helper function to calculate analyte result using the same method as individual tests
      // This ensures summary calculations match individual test calculations exactly
      function calculateAnalyteResultFromRaw(rawValue, analyte, testId, targetUnit) {
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const sampleInfo = JSON.parse(getElementById("ws-sample-info")?.textContent || "{}");

        // Get test-specific sample metadata - use correct element IDs with hyphens
        const ext = parseFloat(getElementById(`extraction-${testId}`)?.textContent) || 1;
        const dil = parseFloat(getElementById(`dilution-${testId}`)?.textContent) || 1;
        const wt = parseFloat(getElementById(`weight-${testId}`)?.textContent) || 1;

        // Apply sample factors first to get concentration
        const concentrationResult = rawValue * ext * dil / wt;

        // Prepare sample metadata for special unit conversions
        const sampleMetadata = {
          serving_weight: sampleInfo.serving_weight || 1,
          servings_per_package: sampleInfo.servings_per_package || 1
        };

        // Convert from input unit to target unit using enhanced conversion that handles special units
        let scaledResult = wsConvertWithSample(concentrationResult, wsUnitConfig.input_unit, targetUnit, sampleMetadata);

        // Debug logging for unit conversion issues
        if (targetUnit.includes('mg/serving') || targetUnit.includes('mg/package')) {
          console.log(`SUMMARY Unit Conversion Debug for ${analyte} test ${testId}:`);
          console.log(`  Raw instrument value: ${rawValue} ${wsUnitConfig.input_unit}`);
          console.log(`  After sample factors (ext=${ext}, dil=${dil}, wt=${wt}): ${concentrationResult} ${wsUnitConfig.input_unit}`);
          console.log(`  Converted to ${targetUnit}: ${scaledResult}`);
          console.log(`  Sample metadata:`, sampleMetadata);
        }

        // Apply moisture correction if enabled (same logic as individual tests)
        const moistureSettings = getMoistureSettings();
        if (moistureSettings.useMoistureCorrection && moistureSettings.correctionEnabled && moistureSettings.moistureFound && moistureSettings.moistureValue > 0) {
          scaledResult = applyMoistureCorrection(scaledResult, moistureSettings.moistureValue);
        }

        return scaledResult;
      }

      function wsUpdateSummary() {
        console.log("Updating Summary Data - Using RAW VALUE AVERAGING for precision consistency");
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const displayUnit = getCurrentDisplayUnit();
        const sigFigsInput = getElementById("sig-fig-input")?.value;
        const sigFigs = sigFigsInput !== '' && sigFigsInput !== null ? parseInt(sigFigsInput) : 3;
        const isomersMap = JSON.parse(getElementById("ws-isomers-map")?.textContent || "{}");
        getElements('#ws-summary-body tr').forEach(row => {
          const analyte = row.dataset.wsAnalyte;

          const values = [];
          const lodValues = [];
          const loqValues = [];
          const limitValues = [];
          let textEval = "";
          let isSynthetic = false;

          if (isomersMap[analyte]) {
            isSynthetic = true;
            let value = isomersMap[analyte].reduce((sum, { analyte: sub, factor }) => {
              const instrumentInput = getElement(`td[name="ws_mean_${sub}_${displayUnit}"]`);
              const rawValue = parseFloat(instrumentInput?.innerText) || 0;

              if (rawValue === null || isNaN(rawValue)) return sum;

              return sum + rawValue * factor;
            }, 0);
            values.push(value);

            // Calculate LOD/LOQ and limit for synthetic analytes
            // Find any test ID for this synthetic analyte to get the calculation and limit
            const anyTestCheckbox = getElement(`.ws-include[name^="ws_include_${analyte}_"]`);
            if (anyTestCheckbox) {
              const anyTestId = anyTestCheckbox.name.split('_').pop();

              // Calculate LOD/LOQ using proper mode calculation
              const lodRaw = calculateSyntheticLodLoq(analyte, anyTestId, 'lod');
              const loqRaw = calculateSyntheticLodLoq(analyte, anyTestId, 'loq');

              // Convert LOD/LOQ to display units using same calculation method
              const calculatedLod = calculateAnalyteResultFromRaw(lodRaw, analyte, anyTestId, displayUnit);
              const calculatedLoq = calculateAnalyteResultFromRaw(loqRaw, analyte, anyTestId, displayUnit);

              lodValues.push(calculatedLod);
              loqValues.push(calculatedLoq);

              // Get the limit from the test element
              const limitElement = getElementById(`ws_limit_${analyte}_${anyTestId}`);
              const syntheticLimit = limitElement ? parseFloat(limitElement.dataset.wsRaw) || 0 : 0;
              limitValues.push(syntheticLimit);
            } else {
              lodValues.push(0);
              loqValues.push(0);
              limitValues.push(0);
            }
          }

          else {
            // Collect RAW values instead of display values to avoid precision cascade
            getElements(`.ws-include[name^="ws_include_${analyte}_"]`).forEach(cb => {
              if (!cb.checked) return;
              const testId = cb.name.split('_').pop();

              // Get the RAW instrument value (not the calculated display value)
              const instrumentInput = getElement(`input[name="ws_instrument_${analyte}_${testId}"]`);
              const rawValue = instrumentInput?.value === '' ? null : parseFloat(instrumentInput?.value);

              // Skip if no value entered (treat as NT) - but allow actual 0 values
              if (rawValue === null || isNaN(rawValue)) return;

              // Calculate result using same method as individual tests
              const calculatedResult = calculateAnalyteResultFromRaw(rawValue, analyte, testId, displayUnit);

              // Get LOD/LOQ values using synthetic calculation method
              const testRow = getElement(`tr[data-ws-analyte="${analyte}"][data-ws-test="${testId}"]`);
              if (testRow) {
                const lodRaw = calculateSyntheticLodLoq(analyte, testId, 'lod');
                const loqRaw = calculateSyntheticLodLoq(analyte, testId, 'loq');
                const limitRaw = parseFloat(testRow.querySelector('.ws-limit')?.dataset.wsRaw) || 0;

                // Calculate LOD/LOQ using same method as individual tests
                const calculatedLod = calculateAnalyteResultFromRaw(lodRaw, analyte, testId, displayUnit);
                const calculatedLoq = calculateAnalyteResultFromRaw(loqRaw, analyte, testId, displayUnit);

                values.push(calculatedResult);
                lodValues.push(calculatedLod);
                loqValues.push(calculatedLoq);
                limitValues.push(wsConvert(limitRaw, wsUnitConfig.limit_unit, displayUnit)); // Limits don't get sample factors
              }
            });

          }

          const n = values.length;
          const mean = (n === 1) ? values[0] : values.reduce((a, b) => a + b, 0) / n || 0;
          const std = (n === 1) ? 0 : Math.sqrt(values.reduce((s, x) => s + (x - mean) ** 2, 0) / (n || 1));
          const rsd = (n === 1) ? 0 : mean !== 0 ? (std / mean) * 100 : 0;
          const lodMean = (n === 1) ? lodValues[0] : lodValues.reduce((a, b) => a + b, 0) / n || 0;
          const loqMean = (n === 1) ? loqValues[0] : loqValues.reduce((a, b) => a + b, 0) / n || 0;
          let limitMean = (n === 1) ? limitValues[0] : limitValues.reduce((a, b) => a + b, 0) / n || 0;

          // Check if ANY included test exceeds max calibrator
          const analyteInfo = JSON.parse(getElementById("ws-analyte-info")?.textContent || "{}");
          const analyteConfig = analyteInfo[analyte];
          const maxCalibratorRaw = analyteConfig?.max_calibrator;
          
          let exceedsMaxInSummary = false;
          let maxCalibratorDisplaySummary = null;
          
          if (maxCalibratorRaw && maxCalibratorRaw > 0 && n > 0) {
            // Check if ANY included test exceeded the max calibrator
            // This is the correct logic - like <LOQ, if any value can't be reported, flag it
            getElements(`.ws-include[name^="ws_include_${analyte}_"]`).forEach(cb => {
              if (!cb.checked) return; // Skip unchecked tests
              
              const testId = cb.name.split('_').pop();
              
              // Check if this specific test exceeded the calibrator
              const testRow = getElement(`tr[data-ws-analyte="${analyte}"][data-ws-test="${testId}"]`);
              if (testRow) {
                const instrumentInput = getElement(`input[name="ws_instrument_${analyte}_${testId}"]`);
                const rawValue = instrumentInput?.value === '' ? null : parseFloat(instrumentInput?.value);
                
                // Only check tests that have actual data
                if (rawValue !== null && !isNaN(rawValue)) {
                  // Compare RAW instrument value against RAW max calibrator (in instrument units)
                  if (rawValue > maxCalibratorRaw) {
                    exceedsMaxInSummary = true;
                    
                    // Calculate the display max for this test (for showing ">value")
                    if (!maxCalibratorDisplaySummary) {
                      maxCalibratorDisplaySummary = calculateAnalyteResultFromRaw(
                        maxCalibratorRaw, 
                        analyte, 
                        testId, 
                        displayUnit
                      );
                    }
                  }
                }
              }
            });
          }

          let status = "-";
          const strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
          
          // Check user preference for reporting above curve
          const reportAboveCurve = getElementById("report-above-curve-checkbox")?.checked || false;
          
          let output;
          if (exceedsMaxInSummary && !reportAboveCurve && maxCalibratorDisplaySummary) {
            // Show ">max" instead of numeric value
            output = `>${applyNumberFormatting(maxCalibratorDisplaySummary, sigFigs, strategy)}`;
          } else {
            output = applyNumberFormatting(mean, sigFigs, strategy);
          }

          // Only calculate Pass/Fail status if compliance mode is enabled
          if (isComplianceMode() && limitMean > 0) {
            if (exceedsMaxInSummary && !reportAboveCurve) {
              // Automatic fail if exceeds calibration curve
              status = "Fail";
            } else {
              let valueForComparison = mean;

              // If uncertainty mode is enabled, use (value - uncertainty) for pass/fail determination
              if (isUncertaintyMode() && wsUnitConfig.uncertainty_data && wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`]) {
                const uncertaintyPercent = wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`];
                const uncertaintyValue = mean * uncertaintyPercent / 100;
                valueForComparison = mean - uncertaintyValue;
              }

              status = (valueForComparison <= limitMean) ? "Pass" : "Fail";
            }
          }

          // QC Check: Compare LOQ to limit for this analyte
          let qcWarning = false;
          if (parseFloat(limitMean) > 0 && loqMean > parseFloat(limitMean)) {
            qcWarning = true;
            // Only upgrade to warning if compliance mode is enabled
            if (isComplianceMode() && status === "Pass") {
              status = "Warning"; // Upgrade to warning if QC issue detected
            }
          }

          // Apply result type logic - check in proper order
          if (n === 0) {
            output = "NT";
          } else if (isSynthetic) {
            // For synthetic analytes, check if result should be ND/<LOQ based on calculated thresholds
            const anyTestCheckbox = getElement(`.ws-include[name^="ws_include_${analyte}_"]`);
            if (anyTestCheckbox) {
              const anyTestId = anyTestCheckbox.name.split('_').pop();
              const syntheticStatus = checkSyntheticAnalyteStatus(mean, analyte, anyTestId, displayUnit);
              if (syntheticStatus) {
                output = syntheticStatus;
              }
            }
          } else if (mean < lodMean && isLodDisplayEnabled()) {
            output = "ND";
          } else if (mean < loqMean) {
            output = "<LOQ";
          }

          // Update all unit-specific result cells in the summary table
          const selectedUnits = getSelectedOutputUnits();
          const sampleInfo = JSON.parse(getElementById("ws-sample-info")?.textContent || "{}");

          selectedUnits.forEach(unit => {
            // Calculate mean for this specific unit directly from raw values to avoid precision loss
            let unitValues = [];
            let unitLodValues = [];
            let unitLoqValues = [];

            if (isSynthetic) {
              // For synthetic analytes, recalculate from constituent raw values in this unit
              let unitValue = isomersMap[analyte].reduce((sum, { analyte: sub, factor }) => {
                const instrumentInput = getElement(`td[name="ws_mean_${sub}_${unit}"]`);
                const rawValue = parseFloat(instrumentInput?.innerText) || 0;

                if (rawValue === null || isNaN(rawValue)) return sum;
                return sum + rawValue * factor;
              }, 0);
              unitValues.push(unitValue);
              unitLodValues.push(0);
              unitLoqValues.push(0);
            } else {
              // For normal analytes, recalculate from raw values in this unit
              getElements(`.ws-include[name^="ws_include_${analyte}_"]`).forEach(cb => {
                if (!cb.checked) return;
                const testId = cb.name.split('_').pop();

                const instrumentInput = getElement(`input[name="ws_instrument_${analyte}_${testId}"]`);
                const rawValue = instrumentInput?.value === '' ? null : parseFloat(instrumentInput?.value);

                // Skip if no value entered (treat as NT) - but allow actual 0 values
                if (rawValue === null || isNaN(rawValue)) return;

                // Calculate result in this specific unit
                const calculatedResult = calculateAnalyteResultFromRaw(rawValue, analyte, testId, unit);

                // Calculate LOD/LOQ using synthetic calculation method
                const testRow = getElement(`tr[data-ws-analyte="${analyte}"][data-ws-test="${testId}"]`);
                if (testRow) {
                  const lodRaw = calculateSyntheticLodLoq(analyte, testId, 'lod');
                  const loqRaw = calculateSyntheticLodLoq(analyte, testId, 'loq');

                  const calculatedLod = calculateAnalyteResultFromRaw(lodRaw, analyte, testId, unit);
                  const calculatedLoq = calculateAnalyteResultFromRaw(loqRaw, analyte, testId, unit);

                  unitValues.push(calculatedResult);
                  unitLodValues.push(calculatedLod);
                  unitLoqValues.push(calculatedLoq);
                }
              });
            }

            // Calculate statistics for this unit
            const unitN = unitValues.length;
            const unitMean = unitN > 0 ? unitValues.reduce((a, b) => a + b, 0) / unitN : 0;
            const unitLodMean = unitLodValues.length > 0 ? unitLodValues.reduce((a, b) => a + b, 0) / unitLodValues.length : 0;
            const unitLoqMean = unitLoqValues.length > 0 ? unitLoqValues.reduce((a, b) => a + b, 0) / unitLoqValues.length : 0;

            // Check if ANY included test exceeds max calibrator for this unit
            let exceedsMaxInUnit = false;
            let maxCalibratorForUnit = null;
            
            if (maxCalibratorRaw && maxCalibratorRaw > 0 && unitN > 0) {
              // Check if ANY included test exceeded the max calibrator
              getElements(`.ws-include[name^="ws_include_${analyte}_"]`).forEach(cb => {
                if (!cb.checked) return; // Skip unchecked tests
                
                const testId = cb.name.split('_').pop();
                const instrumentInput = getElement(`input[name="ws_instrument_${analyte}_${testId}"]`);
                const rawValue = instrumentInput?.value === '' ? null : parseFloat(instrumentInput?.value);
                
                // Only check tests that have actual data
                if (rawValue !== null && !isNaN(rawValue)) {
                  // Compare RAW instrument value against RAW max calibrator (in instrument units)
                  if (rawValue > maxCalibratorRaw) {
                    exceedsMaxInUnit = true;
                    
                    // Calculate the display max for this unit (for showing ">value")
                    if (!maxCalibratorForUnit) {
                      maxCalibratorForUnit = calculateAnalyteResultFromRaw(
                        maxCalibratorRaw,
                        analyte,
                        testId,
                        unit
                      );
                    }
                  }
                }
              });
            }

            // Apply number formatting
            let unitOutput;
            if (exceedsMaxInUnit && !reportAboveCurve && maxCalibratorForUnit) {
              // Show ">max" for this unit
              unitOutput = `>${applyNumberFormatting(maxCalibratorForUnit, sigFigs, strategy)}`;
            } else {
              unitOutput = applyNumberFormatting(unitMean, sigFigs, strategy);
            }

            // Apply the same logic for NT/ND/LOQ in this unit
            if (unitN === 0) { unitOutput = "NT"; }
            else if (isSynthetic) {
              // For synthetic analytes, check if result should be ND/<LOQ based on calculated thresholds
              const anyTestCheckbox = getElement(`.ws-include[name^="ws_include_${analyte}_"]`);
              if (anyTestCheckbox) {
                const anyTestId = anyTestCheckbox.name.split('_').pop();
                const syntheticStatus = checkSyntheticAnalyteStatus(unitMean, analyte, anyTestId, unit);
                if (syntheticStatus) {
                  unitOutput = syntheticStatus;
                }
              }
            }
            else if (unitMean < unitLodMean && isLodDisplayEnabled()) { unitOutput = "ND"; }
            else if (unitMean < unitLoqMean) { unitOutput = "<LOQ"; }

            // Add uncertainty if enabled and uncertainty data is available
            if (isUncertaintyMode() && wsUnitConfig.uncertainty_data && wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`]) {
              const uncertaintyPercent = wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`];
              const uncertaintyValue = unitMean * uncertaintyPercent / 100;
              if (!["NT", "ND", "<LOQ"].includes(unitOutput)) {
                unitOutput = `${unitMean.toFixed(sigFigs)} ± ${uncertaintyValue.toFixed(sigFigs)}`;
              }
            }

            // Find and update the unit-specific cell
            const unitCell = row.querySelector(`[name="ws_mean_${analyte}_${unit}"]`);
            if (unitCell) {
              unitCell.textContent = unitOutput;

              // Apply result type styling to each unit cell
              unitCell.classList.remove('result-nt', 'result-nd', 'result-loq', 'result-normal', 'result-above-curve', 'limit-warning', 'critical-value');
              unitCell.classList.add(getResultTypeClass(unitOutput));
              
              // Add above-curve styling if applicable
              if (exceedsMaxInUnit && !reportAboveCurve) {
                unitCell.classList.add('result-above-curve');
              }

              // Check for critical values (close to limits) for this unit
              if (limitMean > 0 && status === 'Pass' && !exceedsMaxInUnit) {
                const unitLimitValue = wsConvert(parseFloat(limitMean), displayUnit, unit);
                let unitResultValue = unitMean; // Use the numeric value, not the formatted string

                // If uncertainty mode is enabled, use (value - uncertainty) for critical value warnings
                if (isUncertaintyMode() && wsUnitConfig.uncertainty_data && wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`]) {
                  const uncertaintyPercent = wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`];
                  const uncertaintyValue = unitMean * uncertaintyPercent / 100;
                  unitResultValue = unitMean - uncertaintyValue;
                }

                if (!isNaN(unitResultValue) && !isNaN(unitLimitValue)) {
                  const ratio = unitResultValue / unitLimitValue;
                  if (ratio > 0.95) {
                    unitCell.classList.add('critical-value');
                  } else if (ratio > 0.8) {
                    unitCell.classList.add('limit-warning');
                  }
                }
              }
            }
          });

          // Keep the legacy single cell for backward compatibility (using display unit)
          const legacySummaryCell = row.querySelector('.ws-summary-mean:not([data-unit])');
          if (legacySummaryCell) {
            let legacyOutput = output;

            // Add uncertainty to legacy cell if enabled and uncertainty data is available
            if (isUncertaintyMode() && wsUnitConfig.uncertainty_data && wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`]) {
              const uncertaintyPercent = wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`];
              const uncertaintyValue = mean * uncertaintyPercent / 100;
              if (!["NT", "ND", "<LOQ"].includes(output) && !output.startsWith('>')) {
                legacyOutput = `${mean.toFixed(sigFigs)} ± ${uncertaintyValue.toFixed(sigFigs)}`;
              }
            }

            legacySummaryCell.textContent = legacyOutput;
            legacySummaryCell.classList.remove('result-nt', 'result-nd', 'result-loq', 'result-normal', 'result-above-curve', 'limit-warning', 'critical-value');
            legacySummaryCell.classList.add(getResultTypeClass(output));
            
            // Add above-curve styling if applicable
            if (exceedsMaxInSummary && !reportAboveCurve) {
              legacySummaryCell.classList.add('result-above-curve');
            }
          }
          row.querySelector('.ws-summary-lod').textContent = applyNumberFormatting(lodMean, sigFigs, strategy);

          const summaryLoqCell = row.querySelector('.ws-summary-loq');
          summaryLoqCell.textContent = applyNumberFormatting(loqMean, sigFigs, strategy);

          // Apply QC warning to summary LOQ if needed
          summaryLoqCell.classList.remove('loq-qc-warning');
          if (qcWarning) {
            summaryLoqCell.classList.add('loq-qc-warning');
            summaryLoqCell.title = `QC WARNING: LOQ (${loqMean.toFixed(sigFigs)}) exceeds action limit (${limitMean}). Method detection capability insufficient for required limit.`;
          }

          // Display limit in summary - only show if compliance mode is enabled
          const summaryLimitCell = row.querySelector('.ws-summary-limit');
          if (isComplianceMode() && limitMean > 0) {
            summaryLimitCell.textContent = applyNumberFormatting(limitMean, sigFigs, strategy);
          } else {
            summaryLimitCell.textContent = "-";
          }

          // Enhanced status display with icons
          const statusCell = row.querySelector('.ws-summary-status');
          statusCell.innerHTML = `${getStatusIcon(status)}${status}`;
          applyStatusStyling(statusCell, status);

          // Handle RSD display and status
          const rsdCell = row.querySelector('.ws-summary-rsd');
          if (n > 1) {
            const rsdStatus = getRSDStatus(rsd, wsUnitConfig);
            rsdCell.textContent = applyNumberFormatting(rsd, sigFigs, strategy);

            // Remove existing RSD classes
            rsdCell.classList.remove('rsd-pass', 'rsd-warning', 'rsd-fail');
            // Add new RSD status class
            if (rsdStatus.class) {
              rsdCell.classList.add(rsdStatus.class);
            }

            // Add status indicator
            if (rsdStatus.indicator) {
              rsdCell.innerHTML = `${rsd.toFixed(sigFigs)}<span class="rsd-status-indicator">${rsdStatus.indicator}</span>`;
            }

            // Create detailed tooltip data for RSD diagnostics
            const tooltipData = createRSDTooltipData(analyte, values, mean, std, rsd, sigFigs);
            addRSDTooltip(rsdCell, tooltipData);

          } else {
            rsdCell.textContent = n === 0 ? "NT" : "-";
            rsdCell.classList.remove('rsd-pass', 'rsd-warning', 'rsd-fail');
            rsdCell.removeAttribute('title'); // Remove any existing tooltip
          }

          if (status === "Fail") {
            row.style.backgroundColor = "#f8d7da";  // light red
          } else {
            row.style.backgroundColor = "";  // reset if status changes back
          }
        });

        // Generate final results after summary update
        wsGenerateFinalResults();

        // Update statistics after summary update
        wsUpdateStatistics();

        // Update homogeneity table after summary update
        generateHomogeneityTable();

        // Update homogeneity summary column
        updateHomogeneitySummaryColumn();

        // Update overall status banner
        updateOverallStatus();

        // Update tab indicators to reflect current test status
        updateTabIndicators();
      }

      // Update the homogeneity column in the summary table
      function updateHomogeneitySummaryColumn() {
        if (!isHomogeneityEnabled()) return;

        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");

        getElements('#ws-summary-body tr').forEach(row => {
          const analyte = row.dataset.wsAnalyte;
          const homogeneityCell = row.querySelector('.ws-summary-homogeneity');

          if (!homogeneityCell) return;

          // Check if this analyte is included in homogeneity analysis
          const homogeneityRow = document.querySelector(`#homogeneity-table-body tr[data-analyte="${analyte}"]`);
          if (!homogeneityRow) {
            homogeneityCell.textContent = '-';
            homogeneityCell.className = 'ws-summary-homogeneity ws-homogeneity-column';
            return;
          }

          const includeCheckbox = homogeneityRow.querySelector('.ws-homogeneity-include');
          if (!includeCheckbox || !includeCheckbox.checked) {
            homogeneityCell.textContent = '-';
            homogeneityCell.className = 'ws-summary-homogeneity ws-homogeneity-column';
            return;
          }

          // Get homogeneity status from the homogeneity table
          const statusCell = homogeneityRow.querySelector('.hom-status');
          if (statusCell) {
            const status = statusCell.textContent.trim();
            homogeneityCell.textContent = status;

            // Apply styling based on status
            homogeneityCell.className = 'ws-summary-homogeneity ws-homogeneity-column';
            if (status === 'PASS') {
              homogeneityCell.classList.add('hom-status-pass');
            } else if (status === 'FAIL') {
              homogeneityCell.classList.add('hom-status-fail');
            } else {
              homogeneityCell.style.color = '#6c757d';
            }
          } else {
            homogeneityCell.textContent = '-';
            homogeneityCell.className = 'ws-summary-homogeneity ws-homogeneity-column';
          }
        });
      }

      // Toggle visibility of compliance vs homogeneity columns
      function updateColumnVisibility() {
        const isCompliance = isComplianceMode();
        const isHomogeneity = isHomogeneityEnabled();

        // Toggle compliance columns (Limit and Status)
        const complianceColumns = document.querySelectorAll('.ws-compliance-column');
        complianceColumns.forEach(col => {
          col.style.display = isCompliance ? '' : 'none';
        });

        // Toggle homogeneity columns
        const homogeneityColumns = document.querySelectorAll('.ws-homogeneity-column');
        homogeneityColumns.forEach(col => {
          col.style.display = isHomogeneity ? '' : 'none';
        });
      }

      function wsUpdateStatistics() {
        console.log("Updating Statistics Data");
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const displayUnit = getCurrentDisplayUnit();
        const sigFigsInput = getElementById("sig-fig-input")?.value;
        const sigFigs = sigFigsInput !== '' && sigFigsInput !== null ? parseInt(sigFigsInput) : 3;
        const strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
        const isomersMap = JSON.parse(getElementById("ws-isomers-map")?.textContent || "{}");

        getElements('#ws-statistics-body tr').forEach(row => {
          const analyte = row.dataset.wsAnalyte;
          const values = [];
          let isSynthetic = false;

          // Handle synthetic analytes
          if (isomersMap[analyte]) {
            isSynthetic = true;
            let value = isomersMap[analyte].reduce((sum, { analyte: sub, factor }) => {
              // Look for the specific unit cell first, fall back to legacy cell
              const currentDisplayUnit = getCurrentDisplayUnit();
              let subInput = getElement(`[name="ws_mean_${sub}_${currentDisplayUnit}"]`);
              if (!subInput) {
                subInput = getElement(`.ws-summary-mean[name="ws_mean_${sub}"]`);
              }
              const subVal = parseFloat(subInput?.textContent) || 0;
              return sum + subVal * factor;
            }, 0);
            values.push(value);
          } else {
            // Collect values from included tests
            getElements(`.ws-include[name^="ws_include_${analyte}_"]`).forEach(cb => {
              if (!cb.checked) return;
              const testId = cb.name.split('_').pop();

              // Look for the specific unit cell first, fall back to legacy cell
              const currentDisplayUnit = getCurrentDisplayUnit();
              let value = getElement(`[name="ws_final_${analyte}_${testId}_${currentDisplayUnit}"]`);
              if (!value) {
                value = getElement(`.ws-final[name="ws_final_${analyte}_${testId}"]`);
              }

              const val = value?.textContent;

              // Only include numeric values (skip NT, ND, <LOQ)
              if (val && !isNaN(parseFloat(val)) && val !== "NT" && val !== "ND" && !val.includes("<")) {
                values.push(parseFloat(val));
              }
            });
          }

          const n = values.length;

          if (n === 0) {
            // No data available
            row.querySelector('.ws-stats-mean').textContent = "NT";
            row.querySelector('.ws-stats-std').textContent = "NT";
            row.querySelector('.ws-stats-rsd').textContent = "NT";
            row.querySelector('.ws-stats-min').textContent = "NT";
            row.querySelector('.ws-stats-max').textContent = "NT";
            row.querySelector('.ws-stats-count').textContent = "0";
            row.querySelector('.ws-stats-median').textContent = "NT";
            row.querySelector('.ws-stats-range').textContent = "NT";

            // Clear RSD styling
            const rsdCell = row.querySelector('.ws-stats-rsd');
            rsdCell.classList.remove('rsd-pass', 'rsd-warning', 'rsd-fail');
            return;
          }

          // Calculate statistics
          const mean = values.reduce((a, b) => a + b, 0) / n;
          const std = Math.sqrt(values.reduce((s, x) => s + (x - mean) ** 2, 0) / (n > 1 ? n - 1 : 1));
          const rsd = mean !== 0 ? (std / mean) * 100 : 0;
          const min = Math.min(...values);
          const max = Math.max(...values);
          const range = max - min;

          // Calculate median
          const sortedValues = [...values].sort((a, b) => a - b);
          let median;
          if (n % 2 === 0) {
            median = (sortedValues[n / 2 - 1] + sortedValues[n / 2]) / 2;
          } else {
            median = sortedValues[Math.floor(n / 2)];
          }

          // Update table cells
          row.querySelector('.ws-stats-mean').textContent = applyNumberFormatting(mean, sigFigs, strategy);
          row.querySelector('.ws-stats-std').textContent = applyNumberFormatting(std, sigFigs, strategy);
          row.querySelector('.ws-stats-min').textContent = applyNumberFormatting(min, sigFigs, strategy);
          row.querySelector('.ws-stats-max').textContent = applyNumberFormatting(max, sigFigs, strategy);
          row.querySelector('.ws-stats-count').textContent = n.toString();
          row.querySelector('.ws-stats-median').textContent = applyNumberFormatting(median, sigFigs, strategy);
          row.querySelector('.ws-stats-range').textContent = applyNumberFormatting(range, sigFigs, strategy);

          // Handle RSD display and status
          const rsdCell = row.querySelector('.ws-stats-rsd');
          if (n > 1) {
            const rsdStatus = getRSDStatus(rsd, wsUnitConfig);

            // Remove existing RSD classes
            rsdCell.classList.remove('rsd-pass', 'rsd-warning', 'rsd-fail');
            // Add new RSD status class
            if (rsdStatus.class) {
              rsdCell.classList.add(rsdStatus.class);
            }

            // Add status indicator
            if (rsdStatus.indicator) {
              rsdCell.innerHTML = `${applyNumberFormatting(rsd, sigFigs, strategy)}%<span class="rsd-status-indicator">${rsdStatus.indicator}</span>`;
            } else {
              rsdCell.textContent = applyNumberFormatting(rsd, sigFigs, strategy) + '%';
            }
          } else {
            rsdCell.textContent = "-";
            rsdCell.classList.remove('rsd-pass', 'rsd-warning', 'rsd-fail');
          }
        });
      }
      function updateHeaders(currentDisplayUnit) {
        getElementsByName("final-header").forEach(e => { e.textContent = `Final Result (${currentDisplayUnit})` });
        getElementsByName("limit-header").forEach(e => { e.textContent = `Limit (${currentDisplayUnit})` });
        getElementsByName("lod-header").forEach(e => { e.textContent = `LOD (${currentDisplayUnit})` });
        getElementsByName("loq-header").forEach(e => { e.textContent = `LOQ (${currentDisplayUnit})` });

        // Update statistics headers
        getElementsByName("stats-mean-header").forEach(e => { e.textContent = `Mean (${currentDisplayUnit})` });
        getElementsByName("stats-std-header").forEach(e => { e.textContent = `Std Dev (${currentDisplayUnit})` });
        getElementsByName("stats-min-header").forEach(e => { e.textContent = `Min (${currentDisplayUnit})` });
        getElementsByName("stats-max-header").forEach(e => { e.textContent = `Max (${currentDisplayUnit})` });
        getElementsByName("stats-median-header").forEach(e => { e.textContent = `Median (${currentDisplayUnit})` });
        getElementsByName("stats-range-header").forEach(e => { e.textContent = `Range (${currentDisplayUnit})` });
      }

      function wsGenerateFinalResults() {
        console.log("Generating Final Results JSON");
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const isomersMap = JSON.parse(getElementById("ws-isomers-map")?.textContent || "{}");
        const sampleInfo = JSON.parse(getElementById("ws-sample-info")?.textContent || "{}");

        // Get selected output units for multi-unit generation
        const outputUnits = getSelectedOutputUnits();
        console.log("Generating final results for units:", outputUnits);

        const sigFigsInput = getElementById("sig-fig-input")?.value;
        const sigFigs = sigFigsInput !== '' && sigFigsInput !== null ? parseInt(sigFigsInput) : 3;

        // Get analytes from the summary table rows
        const analyteElements = getElements('#ws-summary-body tr[data-ws-analyte]');
        const analytes = Array.from(analyteElements).map(row => row.dataset.wsAnalyte);

        // Get all test rows and collect sample metadata from tests that are included in calculations
        const testRows = getElements('tr[data-ws-analyte][data-ws-test]');
        const includedTestIds = new Set();

        // Find all tests that have at least one analyte included in calculations
        testRows.forEach(row => {
          const testId = row.getAttribute('data-ws-test');
          const analyte = row.getAttribute('data-ws-analyte');
          const includeCheckbox = getElement(`input[name="ws_include_${analyte}_${testId}"]`);

          if (includeCheckbox && includeCheckbox.checked) {
            includedTestIds.add(testId);
          }
        });

        // Calculate average sample metadata from included tests
        let totalExtraction = 0, totalDilution = 0, totalWeight = 0;
        let validExtractionCount = 0, validDilutionCount = 0, validWeightCount = 0;

        includedTestIds.forEach(testId => {
          const extElement = getElementById(`extraction-${testId}`);
          const dilElement = getElementById(`dilution-${testId}`);
          const wtElement = getElementById(`weight-${testId}`);

          if (extElement && extElement.textContent) {
            const extValue = parseFloat(extElement.textContent);
            if (!isNaN(extValue) && extValue > 0) {
              totalExtraction += extValue;
              validExtractionCount++;
            }
          }

          if (dilElement && dilElement.textContent) {
            const dilValue = parseFloat(dilElement.textContent);
            if (!isNaN(dilValue) && dilValue > 0) {
              totalDilution += dilValue;
              validDilutionCount++;
            }
          }

          if (wtElement && wtElement.textContent) {
            const wtValue = parseFloat(wtElement.textContent);
            if (!isNaN(wtValue) && wtValue > 0) {
              totalWeight += wtValue;
              validWeightCount++;
            }
          }
        });

        // Calculate averages or use fallback values if no valid data found
        const ext = validExtractionCount > 0 ? totalExtraction / validExtractionCount : 1;
        const dil = validDilutionCount > 0 ? totalDilution / validDilutionCount : 1;
        const wt = validWeightCount > 0 ? totalWeight / validWeightCount : 1;
        const inhalableType = getElementById('inhalable')?.textContent || 'ingested';

        // Log the averaging results for debugging
        console.log(`Final results sample metadata averaging:`, {
          includedTests: Array.from(includedTestIds),
          extraction: { average: ext, count: validExtractionCount },
          dilution: { average: dil, count: validDilutionCount },
          weight: { average: wt, count: validWeightCount }
        });
        // Calculate multiplication factor (extraction * dilution / weight)
        const multFactor = (ext * dil) / wt;

        const finalResults = {
          analysis_date: new Date().toLocaleDateString('en-US'),
          dilution: dil,
          extraction_volume: ext,
          testing_weight: wt,
          input_units: wsUnitConfig.input_unit,
          report_units: outputUnits,  // All selected output units (greenfield multi-unit design)
          selected_output_units: outputUnits,  // Same as report_units for consistency
          is_compliance: getElementById('compliance-checkbox')?.checked || false,
          use_uncertainty: getElementById('uncertainty-checkbox')?.checked || false,
          is_inhalable: inhalableType.toLowerCase(),
          mult_factor: multFactor,
          sample_matrix: inhalableType === 'Inhaled' ? 'Inhalable' : 'Ingestible',
          sample_id: sampleInfo.sample_id || '',
          sample_name: sampleInfo.sample_name || '',
          sample_qbn_id: sampleInfo.sample_qbn_id || null,
          serving_weight: sampleInfo.serving_weight || 0,
          servings_per_package: sampleInfo.servings_per_package || 0
        };

        // Add current user settings for persistence across reloads
        finalResults.user_settings = {
          compliance_enabled: getElementById('compliance-checkbox')?.checked || false,
          uncertainty_enabled: getElementById('uncertainty-checkbox')?.checked || false,
          report_above_curve_enabled: getElementById('report-above-curve-checkbox')?.checked || false,
          selected_output_units: [...outputUnits],
          current_display_unit: getCurrentDisplayUnit(),
          sig_figs: sigFigs,
          number_format_strategy: getElementById("number-format-strategy")?.value || "fixed_decimals",
          rsd_warning_limit: parseInt(getElementById("rsd-warning-limit")?.value) || 15,
          rsd_fail_limit: parseInt(getElementById("rsd-fail-limit")?.value) || 25,
          rsd_check_enabled: getElementById("rsd-check-enabled")?.checked !== false,
          moisture_correction_enabled: getElementById("moisture-correction-enabled")?.checked || false,
          moisture_reporting_enabled: getElementById("moisture-reporting-enabled")?.checked || false,
          lod_display_enabled: getElementById("lod-display-enabled")?.checked !== false,
          homogeneity_enabled: getElementById("homogeneity-enabled")?.checked || false
        };

        let overallStatus = isComplianceMode() ? "Pass" : "N/A";

        // Process each analyte - just read values directly from summary table
        analytes.forEach(analyte => {
          // Get summary row for this analyte - just read the displayed values
          const summaryRow = getElement(`tr[data-ws-analyte="${analyte}"]`);
          if (!summaryRow) return;

          // Get status directly from summary table
          const statusRaw = summaryRow.querySelector('.ws-summary-status')?.textContent || "-";
          const status = statusRaw.replace(/[✓✗⚠–]/g, '').trim();

          // Get RSD data from summary table
          const rsdCell = summaryRow.querySelector('.ws-summary-rsd');
          const rsdText = rsdCell?.textContent || "0";
          const analyteRSD = parseFloat(rsdText.replace(/[^\d.-]/g, '')) || 0;

          // Simple RSD status determination
          let rsdStatus = 'unknown';
          if (rsdCell?.classList.contains('rsd-pass')) rsdStatus = 'pass';
          else if (rsdCell?.classList.contains('rsd-warning')) rsdStatus = 'warning';
          else if (rsdCell?.classList.contains('rsd-fail')) rsdStatus = 'fail';

          // Get LOD/LOQ from current display unit (same for all output units)
          const currentDisplayUnit = getCurrentDisplayUnit();
          const lodCell = summaryRow.querySelector('.ws-summary-lod');
          const loqCell = summaryRow.querySelector('.ws-summary-loq');
          const lodText = lodCell?.textContent?.trim() || "0";
          const loqText = loqCell?.textContent?.trim() || "0";

          // Generate results for each selected output unit
          const prefix = analyte;

          outputUnits.forEach(outputUnit => {
            // Create safe unit suffix for field names
            const unitSuffix = outputUnit.toLowerCase().replace('%', 'percent').replace(/[^a-z0-9]/g, '_');

            // Get the mean cell for THIS specific output unit
            const meanCell = summaryRow.querySelector(`[name="ws_mean_${analyte}_${outputUnit}"]`);

            // Store the unit-specific final value
            finalResults[`${prefix}_final_${unitSuffix}`] = meanCell?.textContent?.trim() || "NT";

            // For fields that need numeric values, only parse when absolutely necessary
            const meanText = meanCell?.textContent?.trim() || "NT";
            let calcValue = 0;
            if (meanText !== "NT" && meanText !== "ND" && !meanText.includes("<")) {
              calcValue = parseFloat(meanText.replace(/[^\d.-]/g, '')) || 0;
            }
            finalResults[`${prefix}_calc_value_${unitSuffix}`] = calcValue;

            // Only include LOD/LOQ/limit values for the current display unit
            if (outputUnit === currentDisplayUnit) {
              // LOD/LOQ values (only for current display unit)
              finalResults[`${prefix}_lod_${unitSuffix}`] = lodText;
              finalResults[`${prefix}_loq_${unitSuffix}`] = loqText;

              // For backwards compatibility, add numeric versions
              const lodValue = parseFloat(lodText.replace(/[^\d.-]/g, '')) || 0;
              const loqValue = parseFloat(loqText.replace(/[^\d.-]/g, '')) || 0;
              finalResults[`${prefix}_lod_value_${unitSuffix}`] = lodValue;
              finalResults[`${prefix}_loq_value_${unitSuffix}`] = loqValue;

              // Calculate limit only for current display unit
              const testRow = getElement(`tr[data-ws-analyte="${analyte}"][data-ws-test]`);
              let limitValue = null;
              let maxCalibratorValue = null;
              let exceedsCurve = false;
              
              if (testRow) {
                const limitRaw = parseFloat(testRow.querySelector('.ws-limit')?.dataset.wsRaw) || 0;
                if (limitRaw > 0) {
                  const sampleMetadata = {
                    serving_weight: sampleInfo.serving_weight || 1,
                    servings_per_package: sampleInfo.servings_per_package || 1
                  };
                  const baseLimitValue = wsConvert(limitRaw, wsUnitConfig.limit_unit, wsUnitConfig.input_unit);
                  limitValue = wsConvertWithSample(baseLimitValue, wsUnitConfig.input_unit, outputUnit, sampleMetadata);
                }
                
                // Add max calibrator data
                const analyteInfo = JSON.parse(getElementById("ws-analyte-info")?.textContent || "{}");
                const analyteConfig = analyteInfo[analyte];
                const maxCalibratorRaw = analyteConfig?.max_calibrator;
                
                if (maxCalibratorRaw && maxCalibratorRaw > 0) {
                  const sampleMetadata = {
                    serving_weight: sampleInfo.serving_weight || 1,
                    servings_per_package: sampleInfo.servings_per_package || 1
                  };
                  maxCalibratorValue = wsConvertWithSample(maxCalibratorRaw * ext * dil / wt, wsUnitConfig.input_unit, outputUnit, sampleMetadata);
                  
                  // Check if result exceeds calibrator
                  exceedsCurve = calcValue > maxCalibratorValue;
                }
              }
              
              finalResults[`${prefix}_limit_${unitSuffix}`] = limitValue;
              finalResults[`${prefix}_max_calibrator_${unitSuffix}`] = maxCalibratorValue;
              finalResults[`${prefix}_exceeds_curve_${unitSuffix}`] = exceedsCurve;

              // Fail direction (only for current display unit)
              let failDirection = "N/A";
              if (status === "Fail" && limitValue > 0 && calcValue > 0) {
                failDirection = calcValue > limitValue ? "High" : "Low";
              } else if (status === "Fail" && exceedsCurve) {
                failDirection = "Above Curve";
              }
              finalResults[`${prefix}_fail_direction_${unitSuffix}`] = failDirection;

              // QC warning (only for current display unit)
              if (limitValue > 0 && loqValue > limitValue) {
                finalResults[`${prefix}_qc_warning_${unitSuffix}`] = `LOQ (${lodText}) exceeds action limit (${limitValue.toFixed(3)})`;
              } else {
                finalResults[`${prefix}_qc_warning_${unitSuffix}`] = null;
              }
            }
          });

          // Unit-independent status fields (shared across all units)
          finalResults[`${prefix}_status`] = status;
          finalResults[`${prefix}_rsd_percent`] = analyteRSD.toFixed(2);
          finalResults[`${prefix}_rsd_status`] = rsdStatus;

          // Get homogeneity status for this analyte
          const homogeneityStatus = getAnalyteHomogeneityStatus(analyte);
          finalResults[`${prefix}_homogeneity_status`] = homogeneityStatus;

          // Get uncertainty data for this analyte
          let uncertaintyPercent = 0;
          if (isUncertaintyMode() && wsUnitConfig.uncertainty_data && wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`]) {
            uncertaintyPercent = wsUnitConfig.uncertainty_data[`${analyte}_uncertainty`];
          }
          finalResults[`${prefix}_uncertainty_percent`] = uncertaintyPercent;

          // Update overall status (only if compliance mode is enabled)
          if (isComplianceMode()) {
            if (status === "Fail") {
              overallStatus = "Fail";
            }
          } else {
            // In non-compliance mode, don't update overall status based on Pass/Fail
            overallStatus = "N/A";
          }
        });

        finalResults.overall_status = overallStatus;

        // Add overall homogeneity status
        finalResults.overall_homogeneity_status = getHomogeneityStatus();

        // Add moisture correction metadata
        const moistureSettings = getMoistureSettings();
        const moistureCorrectionApplied = moistureSettings.useMoistureCorrection && moistureSettings.reportingEnabled && moistureSettings.moistureFound && moistureSettings.moistureValue > 0;

        finalResults.moisture_correction_enabled = moistureSettings.useMoistureCorrection;
        finalResults.moisture_content_percent = moistureSettings.moistureValue;
        finalResults.moisture_found = moistureSettings.moistureFound;
        finalResults.moisture_correction_applied = moistureCorrectionApplied;
        finalResults.assay_type = moistureSettings.assayName;
        finalResults.results_basis = moistureCorrectionApplied ? "dry_weight" : "as_tested";

        // Save to final results field
        const finalField = getFinalField();
        if (finalField) {
          finalField.value = JSON.stringify(finalResults);
        }

        // Generate Confident Cannabis integration fields
        generateConfidentFields(finalResults, analytes, outputUnits);

        return finalResults;
      }

      // Generate Confident Cannabis integration fields
      // Creates hidden form fields that can be read by API automations
      function generateConfidentFields(finalResults, analytes, outputUnits) {
        console.log("Generating Confident Cannabis integration fields");

        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");

        // Use the confident_report_unit from configuration for CC export
        const ccReportUnit = wsUnitConfig.confident_report_unit || outputUnits[0] || 'ppb';
        console.log(`Using ${ccReportUnit} as Confident Cannabis export unit (from confident_report_unit config)`);

        analytes.forEach(analyte => {
          // Get values directly from the summary table for the confident report unit
          const summaryRow = getElement(`tr[data-ws-analyte="${analyte}"]`);
          if (!summaryRow) return;

          const summaryCell = summaryRow.querySelector(`[name="ws_mean_${analyte}_${ccReportUnit}"]`);
          const finalText = summaryCell ? summaryCell.textContent.trim() : "NT";

          // Get LOD and LOQ directly from summary table (exact values)
          const lodCell = summaryRow.querySelector('.ws-summary-lod');
          const loqCell = summaryRow.querySelector('.ws-summary-loq');
          const limitCell = summaryRow.querySelector('.ws-summary-limit');
          const lodText = lodCell ? lodCell.textContent.trim() : "0";
          const loqText = loqCell ? loqCell.textContent.trim() : "0";
          const limitText = limitCell ? limitCell.textContent.trim() : "0";

          // Convert result to numerical value for Confident Cannabis (no formatting changes)
          let ccResult = 0;
          let ccLod = parseFloat(lodText) || 0;
          let ccLoq = parseFloat(loqText) || 0;
          let ccLimit = parseFloat(limitText) || 0;

          if (finalText === "NT") {
            ccResult = 0;
          } else if (finalText === "ND") {
            ccResult = 0;
          } else if (finalText === "<LOQ" || finalText.includes("LOQ")) {
            ccResult = ccLod; // Use LOD for <LOQ cases
          } else if (finalText === "TNTC") {
            // Too Numerous To Count (microbio) - use egregiously high value
            // This ensures it always fails but provides a numerical value
            ccResult = ccLimit > 0 ? ccLimit * 1000 : 999999;
          } else if (!isNaN(parseFloat(finalText))) {
            ccResult = parseFloat(finalText); // Use exact numeric value from summary
          } else {
            const numMatch = finalText.match(/[\d.]+/);
            ccResult = numMatch ? parseFloat(numMatch[0]) : 0;
          }

          // Create or update hidden form fields for Confident Cannabis integration
          createOrUpdateHiddenField(`${analyte}_cc_result`, ccResult);
          createOrUpdateHiddenField(`${analyte}_cc_lod`, ccLod);
          createOrUpdateHiddenField(`${analyte}_cc_loq`, ccLoq);

          // Only create action_limit field if limits are actually being used
          // Check if compliance mode is enabled and limits are configured
          const complianceEnabled = isComplianceMode();
          const hasLimit = ccLimit > 0;

          if (complianceEnabled && hasLimit) {
            createOrUpdateHiddenField(`${analyte}_cc_action_limit`, ccLimit);
          } else {
            // Remove the field if it exists but shouldn't be there
            const existingLimitField = document.querySelector(`input[name="${analyte}_cc_action_limit"]`);
            if (existingLimitField) {
              existingLimitField.remove();
            }
          }

          // Get homogeneity pass/fail status for this analyte (0 = fail, 1 = pass)
          let ccHomogeneityPass = 0; // Default to fail if no homogeneity data

          // Check if homogeneity is enabled
          const homogeneityEnabled = getElementById('homogeneity-enabled')?.checked;
          if (homogeneityEnabled) {
            // Look for homogeneity status in the homogeneity table
            const homogeneityTable = getElementById('homogeneity-table');
            if (homogeneityTable) {
              const analyteRow = homogeneityTable.querySelector(`tr[data-analyte="${analyte}"]`);
              if (analyteRow) {
                const statusCell = analyteRow.querySelector('.homogeneity-status');
                if (statusCell) {
                  const statusText = statusCell.textContent.trim().toLowerCase();
                  ccHomogeneityPass = (statusText === 'pass') ? 1 : 0;
                }
              }
            }
          }

          createOrUpdateHiddenField(`${analyte}_cc_homogeneity_pass`, ccHomogeneityPass);

          console.log(`CC Fields for ${analyte}: result=${ccResult} (from "${finalText}"), lod=${ccLod} (from "${lodText}"), loq=${ccLoq} (from "${loqText}"), limit=${ccLimit}, homogeneity=${ccHomogeneityPass} [unit: ${ccReportUnit}]`);
        });

        // Calculate overall homogeneity pass/fail status (0 = fail, 1 = pass)
        let ccOverallHomogeneityPass = 0; // Default to fail

        const homogeneityEnabled = getElementById('homogeneity-enabled')?.checked;
        if (homogeneityEnabled) {
          // Check if all analytes with homogeneity data passed
          const homogeneityTable = getElementById('homogeneity-table');
          if (homogeneityTable) {
            const analyteRows = homogeneityTable.querySelectorAll('tr[data-analyte]');
            let hasHomogeneityData = false;
            let allPassed = true;

            analyteRows.forEach(row => {
              const statusCell = row.querySelector('.homogeneity-status');
              if (statusCell && statusCell.textContent.trim() !== '-') {
                hasHomogeneityData = true;
                const statusText = statusCell.textContent.trim().toLowerCase();
                if (statusText !== 'pass') {
                  allPassed = false;
                }
              }
            });

            // Only pass if we have homogeneity data and all analytes passed
            if (hasHomogeneityData && allPassed) {
              ccOverallHomogeneityPass = 1;
            }
          }
        }

        createOrUpdateHiddenField('cc_overall_homogeneity_pass', ccOverallHomogeneityPass);
        console.log(`Overall Homogeneity Pass: ${ccOverallHomogeneityPass}`);

        // Also create a summary field with CC export metadata
        const ccMetadata = {
          export_unit: ccReportUnit,
          export_timestamp: new Date().toISOString(),
          analyte_count: analytes.length,
          source: "QBench_Worksheet_v2.0",
          conversion_notes: {
            "NT": "Converted to 0 (Not Tested)",
            "ND": "Converted to 0 (Not Detected)",
            "<LOQ": "Converted to LOQ value",
            "TNTC": "Converted to limit * 1000 (microbio fail)"
          }
        };

        createOrUpdateHiddenField('cc_export_metadata', JSON.stringify(ccMetadata));

        console.log("✅ Confident Cannabis integration fields generated successfully");

        // Debug: Log generated field examples for verification
        if (analytes.length > 0) {
          const firstAnalyte = analytes[0];
          const exampleField = document.querySelector(`input[name="${firstAnalyte}_cc_result"]`);
          if (exampleField) {
            console.log("Example CC field HTML:", exampleField.outerHTML);
          }
        }
      }

      // Helper function to update QBench condition field values
      // The fields are now created in the Jinja template, so we just update their values
      function createOrUpdateHiddenField(fieldName, value) {
        // Find the existing condition field created by the template
        let field = getElementsByName(fieldName)[0];

        if (!field) {
          console.warn(`Confident Cannabis field '${fieldName}' not found - ensure it's declared in the template`);
          return;
        }

        // Update the true_value in data-kwargs for QBench condition field format
        // field.setAttribute('data-kwargs', `0==0, true_value=${value}, html_style="display:none;"`);

        // Also update the value attribute for good measure
        if (field.value !== undefined) {
          field.value = value;
        }

        console.log(`Updated QBench condition field '${fieldName}' with value: ${value}`);
      }

      // Helper function to format a number to a specific number of significant figures
      function formatToSigFigs(value, sigFigs) {
        if (value === 0 || !isFinite(value)) return "0";

        // Handle negative numbers
        const sign = value < 0 ? -1 : 1;
        value = Math.abs(value);

        // Calculate the order of magnitude
        const orderOfMagnitude = Math.floor(Math.log10(value));

        // Calculate the factor to shift the decimal point
        const factor = Math.pow(10, sigFigs - 1 - orderOfMagnitude);

        // Round to significant figures
        const rounded = Math.round(value * factor) / factor;

        // Apply sign back
        const result = sign * rounded;

        // Format the result
        if (orderOfMagnitude >= sigFigs - 1 || orderOfMagnitude < -4) {
          // Use scientific notation for very large or very small numbers
          return result.toExponential(sigFigs - 1);
        } else {
          // Use fixed notation, but trim unnecessary trailing zeros
          const decimalPlaces = Math.max(0, sigFigs - 1 - orderOfMagnitude);
          return parseFloat(result.toFixed(decimalPlaces)).toString();
        }
      }

      // Helper function to apply number formatting based on selected strategy
      function applyNumberFormatting(convertedValue, sigFigs, strategy) {
        // If no strategy provided, get it from the UI
        if (!strategy) {
          strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
        }

        switch (strategy) {
          case "significant_figures":
            // Use true significant figures (scientifically correct)
            // Ensure minimum of 1 sig fig (0 is invalid for significant figures)
            const minSigFigs = Math.max(1, sigFigs);
            return formatToSigFigs(convertedValue, minSigFigs);

          case "fixed_decimals":
          default:
            // Use fixed decimal places (visual alignment)
            // 0 decimal places = integer formatting
            return convertedValue.toFixed(Math.max(0, sigFigs));
        }
      }

      // Helper function to get the strategy-appropriate source value for unit conversions
      function getValueForStrategy(rawValue, sigFigs, strategy) {
        // If no strategy provided, get it from the UI
        if (!strategy) {
          strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
        }

        switch (strategy) {
          case "significant_figures":
            // Use the displayed (sig-fig rounded) value as the source for conversions
            // Ensure minimum of 1 sig fig (0 is invalid for significant figures)
            const minSigFigs = Math.max(1, sigFigs);
            return parseFloat(formatToSigFigs(rawValue, minSigFigs));

          case "fixed_decimals":
          default:
            // Use the displayed (decimal-rounded) value as the source for conversions
            // 0 decimal places = integer formatting
            return parseFloat(rawValue.toFixed(Math.max(0, sigFigs)));
        }
      }

      // Global function for bulk updating results - accessible from all scopes
      function bulkUpdateResults() {
        const wsInstrumentData = JSON.parse(getInstrumentField()?.value || "{}");
        const wsUpdatedData = JSON.parse(getLiveField()?.value || "{}");
        const isomersMap = JSON.parse(getElementById("ws-isomers-map")?.textContent || "{}");
        const updatedResults = wsUpdatedData;
        const allAnalytes = new Set([
          ...Object.keys(updatedResults || {}),
          ...Object.keys(wsInstrumentData || {})
        ]);

        // First pass: set raw inputs for all direct analytes
        for (const analyte of allAnalytes) {
          const testIds = new Set([
            ...Object.keys(updatedResults?.[analyte] || {}),
            ...Object.keys(wsInstrumentData?.[analyte] || {})
          ]);

          for (const testId of testIds) {
            const input = getElement(`input[name="ws_instrument_${analyte}_${testId}"]`);

            // Skip synthetic analytes with no input field
            if (!input) continue;

            const liveVal = updatedResults?.[analyte]?.[testId];
            const fallbackVal = wsInstrumentData?.[analyte]?.[testId];
            const val = !isNaN(liveVal) ? liveVal : fallbackVal;

            input.value = val;
            wsRecalculate(testId, analyte);
            // Remove wsUpdateSummary() from here - only call once at the end
          }
        }

        // Second pass: recalculate synthetic analytes from isomers_map
        Object.entries(isomersMap).forEach(([syntheticAnalyte, components]) => {
          const testIds = new Set();

          components.forEach(({ analyte }) => {
            Object.keys(updatedResults?.[analyte] || {}).forEach(testId => testIds.add(testId));
            Object.keys(wsInstrumentData?.[analyte] || {}).forEach(testId => testIds.add(testId));
          });

          for (const testId of testIds) {
            wsRecalculate(testId, syntheticAnalyte);
          }
        });

        wsUpdateSummary();

        // Update tab indicators after bulk data changes
        updateTabIndicators();
      }

      // Assay-scoped field helper functions
      function getAssayKey() {
        const assayKeyElement = getElementById('ws-assay-key');
        return assayKeyElement ? assayKeyElement.textContent : 'unknown';
      }

      function getFieldName(baseName) {
        const assayKey = getAssayKey();
        return baseName + '_' + assayKey;
      }

      function getInstrumentField() {
        return getElementsByName(getFieldName('ws_instrument_results'))[0];
      }

      function getLiveField() {
        return getElementsByName(getFieldName('ws_live_results'))[0];

      }

      function getFinalField() {
        return getElementsByName(getFieldName('ws_final_results'))[0];
      }

      function getDeviationField() {
        return getElementsByName(getFieldName('ws_deviations'))[0];
      }

      console.log("Assay-scoped worksheet loaded for:", getAssayKey());

      $(document).ready(function () {
        setTimeout(function () {
          console.log("Loading...");

          const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
          const sampleInfo = JSON.parse(getElementById("ws-sample-info")?.textContent || "{}");

          // Check sample metadata to determine if special units should be available
          const hasServingWeight = sampleInfo.serving_weight && sampleInfo.serving_weight > 0;
          const hasServingsPerPackage = sampleInfo.servings_per_package && sampleInfo.servings_per_package > 0;

          console.log("Sample metadata check:", {
            serving_weight: sampleInfo.serving_weight,
            servings_per_package: sampleInfo.servings_per_package,
            hasServingWeight,
            hasServingsPerPackage
          });

          // Filter allowed units based on available sample metadata
          let allowedUnits = [...(wsUnitConfig.allowed_units || ['ppb'])];

          // Remove mg/serving if no serving weight data
          if (!hasServingWeight && allowedUnits.includes('mg/serving')) {
            allowedUnits = allowedUnits.filter(unit => unit !== 'mg/serving');
            console.log("Removed mg/serving from allowed units - no serving weight data");
          }

          // Remove mg/package if no serving weight OR no servings per package data
          // (mg/package requires both serving size and package quantity)
          if ((!hasServingWeight || !hasServingsPerPackage) && allowedUnits.includes('mg/package')) {
            allowedUnits = allowedUnits.filter(unit => unit !== 'mg/package');
            const reason = !hasServingWeight ? "no serving weight data" : "no servings per package data";
            console.log(`Removed mg/package from allowed units - ${reason}`);
          }

          console.log("Filtered allowed units:", allowedUnits);

          const reportUnits = wsUnitConfig.report_units || 'ppb';
          const defaultUnits = wsUnitConfig.default_units || ['ppb'];

          // Check for saved user settings first
          const savedSettings = getSavedUserSettings();

          // Multi-unit configuration storage - initialize global variable
          if (savedSettings && savedSettings.selected_output_units && savedSettings.selected_output_units.length > 0) {
            // Restore from saved settings, but filter to only allowed units
            selectedOutputUnits = savedSettings.selected_output_units.filter(unit => allowedUnits.includes(unit));
            console.log("Restored selected output units from saved settings:", selectedOutputUnits);
          } else {
            // Use kvstore defaults for first-time loads
            selectedOutputUnits = [...defaultUnits]; // Initialize with default_units from kvstore
            console.log("Using kvstore default units:", selectedOutputUnits);
          }

          // Filter out any units that are no longer allowed due to missing sample metadata
          const originalSelectedCount = selectedOutputUnits.length;
          selectedOutputUnits = selectedOutputUnits.filter(unit => allowedUnits.includes(unit));

          if (selectedOutputUnits.length < originalSelectedCount) {
            const removedUnits = originalSelectedCount > selectedOutputUnits.length ?
              (savedSettings ? savedSettings.selected_output_units : defaultUnits).filter(unit => !allowedUnits.includes(unit)) : [];
            console.log("Removed unavailable units from selection:", removedUnits);
          }

          // Validation: ensure at least one unit is selected and all are valid
          if (selectedOutputUnits.length === 0) {
            selectedOutputUnits = [allowedUnits[0]]; // Fallback to first allowed unit
            console.warn("No valid units found, using first allowed unit:", selectedOutputUnits[0]);
          }

          console.log("Final selected output units:", selectedOutputUnits);

          // Initialize display unit - check saved settings first, then report units, then fallback
          if (savedSettings && savedSettings.current_display_unit && allowedUnits.includes(savedSettings.current_display_unit)) {
            currentDisplayUnit = savedSettings.current_display_unit;
            console.log("Restored display unit from saved settings:", currentDisplayUnit);
          } else if (allowedUnits.includes(reportUnits)) {
            currentDisplayUnit = reportUnits;
            console.log("Using report units as display unit:", currentDisplayUnit);
          } else {
            currentDisplayUnit = selectedOutputUnits[0]; // Use first selected output unit as fallback
            console.warn("Using first selected output unit as display unit:", currentDisplayUnit);
          }

          console.log("Final initialized display unit:", currentDisplayUnit);

          // Populate sample information section
          populateSampleInfoSection(sampleInfo, wsUnitConfig, allowedUnits, selectedOutputUnits, hasServingWeight, hasServingsPerPackage);

          // Initialize multi-unit selector UI
          initializeMultiUnitSelector(allowedUnits, selectedOutputUnits);

          // Initialize display unit selector UI
          initializeDisplayUnitSelector(selectedOutputUnits, currentDisplayUnit);

          // Update headers BEFORE rebuilding tables
          updateHeaders(currentDisplayUnit);

          // Rebuild table structure for multi-unit display (but don't trigger updates yet)
          rebuildTableHeaders();
          rebuildTableRows();

          // Initialize RSD settings - check saved settings first, then kvstore defaults
          if (savedSettings) {
            // Use saved settings if available
            getElementById("rsd-warning-limit").value = savedSettings.rsd_warning_limit || 15;
            getElementById("rsd-fail-limit").value = savedSettings.rsd_fail_limit || 25;
            getElementById("rsd-check-enabled").checked = savedSettings.rsd_check_enabled !== false;
            getElementById("sig-fig-input").value = savedSettings.sig_figs || 3;
            getElementById("number-format-strategy").value = savedSettings.number_format_strategy || "fixed_decimals";
          } else {
            // Use kvstore defaults for first-time loads
            getElementById("rsd-warning-limit").value = wsUnitConfig.rsd_warning_limit || 15;
            getElementById("rsd-fail-limit").value = wsUnitConfig.rsd_fail_limit || 25;
            getElementById("rsd-check-enabled").checked = wsUnitConfig.rsd_check_enabled !== false;
            getElementById("sig-fig-input").value = wsUnitConfig.default_decimal_places || 3;
            getElementById("number-format-strategy").value = wsUnitConfig.default_number_format || "fixed_decimals";
          }

          // Initialize moisture correction display
          updateMoistureDisplay();

          // Initialize moisture correction checkboxes - auto-apply if moisture is valid (only for first-time loads)
          if (!savedSettings && wsUnitConfig.use_moisture_correction && wsUnitConfig.moisture_found) {
            const moistureValid = wsUnitConfig.moisture_value > 0 && wsUnitConfig.moisture_value < 100;
            if (moistureValid) {
              const correctionCheckbox = getElementById("moisture-correction-enabled");
              const reportingCheckbox = getElementById("moisture-reporting-enabled");

              if (correctionCheckbox) correctionCheckbox.checked = true;
              if (reportingCheckbox) reportingCheckbox.checked = true;

              console.log("Auto-applied moisture correction - moisture content:", wsUnitConfig.moisture_value + "%");
            }
          }

          const wsInstrumentData = JSON.parse(getInstrumentField()?.value || "{}");
          const wsUpdatedData = JSON.parse(getLiveField()?.value || "{}");
          const isomersMap = JSON.parse(getElementById("ws-isomers-map")?.textContent || "{}");
          const updatedResults = wsUpdatedData;

          function updateRSDConfig() {
            // Update the unit config with current RSD settings
            const wsUnitConfigElement = document.getElementById("ws-unit-config");
            const currentConfig = JSON.parse(wsUnitConfigElement.textContent);

            currentConfig.rsd_warning_limit = parseInt(document.getElementById("rsd-warning-limit").value) || 15;
            currentConfig.rsd_fail_limit = parseInt(document.getElementById("rsd-fail-limit").value) || 25;
            currentConfig.rsd_check_enabled = document.getElementById("rsd-check-enabled").checked;

            wsUnitConfigElement.textContent = JSON.stringify(currentConfig);

            // Trigger update of all calculations
            bulkUpdateResults();
          }

          getElementById("restore-batch-data-btn").addEventListener('click', () => {
            // Smart Replace Batch Data - only restore data for current assay tests
            const instrumentField = getInstrumentField();
            const liveField = getLiveField();

            if (!instrumentField || !liveField) {
              console.error('Could not find assay-scoped data fields for:', getAssayKey());
              alert('Error: Could not find data fields for this assay.');
              return;
            }

            const wsInstrumentData = JSON.parse(instrumentField.value || "{}");
            const currentLiveData = JSON.parse(liveField.value || "{}");

            // Get the test IDs that are actually in this worksheet (filtered by assay)
            const currentTestIds = new Set();
            getElements('tr[data-ws-test]').forEach(row => {
              const testId = row.getAttribute('data-ws-test');
              if (testId) currentTestIds.add(testId);
            });

            console.log(`Restoring batch data for ${currentTestIds.size} tests in ${getAssayKey()} assay`);

            // Only replace data for tests that are actually in this worksheet
            const updatedLiveData = { ...currentLiveData }; // Start with current data

            Object.entries(wsInstrumentData).forEach(([analyte, tests]) => {
              if (!updatedLiveData[analyte]) updatedLiveData[analyte] = {};

              Object.entries(tests).forEach(([testId, value]) => {
                // Only update if this test is in the current worksheet
                if (currentTestIds.has(testId)) {
                  updatedLiveData[analyte][testId] = value;
                }
                // Leave other test data untouched
              });
            });

            // Update the live field with filtered restoration
            liveField.value = JSON.stringify(updatedLiveData);

            bulkUpdateResults();
            console.log(`✓ Batch data restored for ${getAssayKey()} assay only`);
          });

          getElementById("generate-final-results-btn").addEventListener('click', () => {
            const finalResults = wsGenerateFinalResults();
            console.log("Final Results Generated:", finalResults);
            alert("Final results generated! Check console for details.");
          });

          getElementById("view-final-results-btn").addEventListener('click', () => {
            const finalField = getFinalField();
            const finalResults = finalField?.value || "{}";
            const formatted = JSON.stringify(JSON.parse(finalResults), null, 2);

            // Create a modal or popup to display results
            const popup = window.open('', 'FinalResults', 'width=800,height=600,scrollbars=yes');
            popup.document.write(`
          <html>
            <head><title>Final Results JSON - ${getAssayKey()} Assay</title></head>
            <body>
              <h2>Final Results JSON - ${getAssayKey()} Assay</h2>
              <pre style="background: #f5f5f5; padding: 10px; overflow: auto;">${formatted}</pre>
              <button onclick="window.close()">Close</button>
            </body>
          </html>
        `);
          });

          getElementById("sig-fig-input").addEventListener('change', () => {
            const sigFigsInput = getElementById("sig-fig-input");
            const strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
            const value = parseInt(sigFigsInput.value);
            
            // Validate: 0 is only allowed in fixed_decimals mode
            if (value === 0 && strategy === "significant_figures") {
              alert("Warning: 0 significant figures is invalid. Using 1 instead.\n\nTo use integer formatting, switch to 'Fixed Decimal Places' mode.");
              sigFigsInput.value = "1";
            }
            
            bulkUpdateResults();
          });

          getElementById("number-format-strategy").addEventListener('change', () => {
            console.log("Number format strategy changed:", getElementById("number-format-strategy").value);
            
            // Validate sig figs when switching strategies
            const sigFigsInput = getElementById("sig-fig-input");
            const strategy = getElementById("number-format-strategy")?.value || "fixed_decimals";
            const value = parseInt(sigFigsInput.value);
            
            if (value === 0 && strategy === "significant_figures") {
              alert("Switching to 1 significant figure (0 is invalid for significant figures mode).");
              sigFigsInput.value = "1";
            }
            
            bulkUpdateResults();
          });

          getElementById("compliance-checkbox").addEventListener('change', () => {
            console.log("Compliance mode changed:", getElementById("compliance-checkbox").checked);
            updateColumnVisibility();
            bulkUpdateResults();
          });

          getElementById("uncertainty-checkbox").addEventListener('change', () => {
            console.log("Uncertainty mode changed:", getElementById("uncertainty-checkbox").checked);
            bulkUpdateResults();
          });

          // Initialize report above curve checkbox event listener
          const reportAboveCurveCheckbox = getElementById("report-above-curve-checkbox");
          if (reportAboveCurveCheckbox) {
            reportAboveCurveCheckbox.addEventListener('change', () => {
              console.log("Report above curve mode changed:", reportAboveCurveCheckbox.checked);
              bulkUpdateResults();
            });
          }

          // Initialize LOD display event listener with null check
          const lodCheckbox = getElementById("lod-display-enabled");
          if (lodCheckbox) {
            lodCheckbox.addEventListener('change', () => {
              console.log("LOD display mode changed:", lodCheckbox.checked);
              toggleLodDisplay();
              bulkUpdateResults();
            });
          }

          // Initialize homogeneity event listener with null check
          const homogeneityCheckbox = getElementById("homogeneity-enabled");
          if (homogeneityCheckbox) {
            homogeneityCheckbox.addEventListener('change', () => {
              console.log("Homogeneity analysis changed:", homogeneityCheckbox.checked);
              updateColumnVisibility();
              toggleHomogeneityTab();
            });
          }

          // Add event listeners for homogeneity include checkboxes
          document.querySelectorAll('.ws-homogeneity-include').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
              console.log("Homogeneity include changed for:", checkbox.name);

              // Update the "Include All" checkbox state based on individual checkboxes
              updateHomogeneityIncludeAllCheckbox();

              if (isHomogeneityEnabled() && hasMinimumReplicatesForHomogeneity()) {
                bulkUpdateResults();
              }
            });
          });

          // Add event listener for homogeneity include all checkbox
          const homogeneityIncludeAllCheckbox = document.querySelector('.ws-homogeneity-include-all');
          if (homogeneityIncludeAllCheckbox) {
            homogeneityIncludeAllCheckbox.addEventListener('change', (e) => {
              const isChecked = e.target.checked;
              console.log("Homogeneity include all changed:", isChecked);

              // Update all individual checkboxes
              document.querySelectorAll('.ws-homogeneity-include').forEach(checkbox => {
                checkbox.checked = isChecked;
              });

              // Regenerate table if homogeneity is enabled
              if (isHomogeneityEnabled() && hasMinimumReplicatesForHomogeneity()) {
                generateHomogeneityTable();
              }
            });
          }

          getElementById("rsd-warning-limit").addEventListener('change', updateRSDConfig);
          getElementById("rsd-fail-limit").addEventListener('change', updateRSDConfig);
          getElementById("rsd-check-enabled").addEventListener('change', updateRSDConfig);

          // Initialize moisture correction event listeners
          const moistureCorrectionCheckbox = getElementById("moisture-correction-enabled");
          const moistureReportingCheckbox = getElementById("moisture-reporting-enabled");

          if (moistureCorrectionCheckbox) {
            moistureCorrectionCheckbox.addEventListener('change', () => {
              updateMoistureDisplay();
              bulkUpdateResults();
              // Note: wsGenerateFinalResults() is called by bulkUpdateResults() -> wsUpdateSummary()
              console.log("Moisture correction for calculations:", moistureCorrectionCheckbox.checked);
            });
          }

          if (moistureReportingCheckbox) {
            moistureReportingCheckbox.addEventListener('change', () => {
              updateMoistureDisplay();
              // Note: For reporting-only changes, we only need to update the final results
              // since the calculations themselves don't change, only the display
              wsGenerateFinalResults();
              console.log("Moisture correction for reporting:", moistureReportingCheckbox.checked);
            });
          }

          // Initialize data integrity protection (without triggering updates)
          setupDataIntegrityUI();

          getElements('.ws-tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              getElements('.ws-tab-content').forEach(div => div.style.display = 'none');
              getElements('.ws-tab-btn').forEach(myBtn => { myBtn.classList.remove("active"); })
              getElementById(`ws-tab-${btn.dataset.wsTab}`).style.display = 'block';
              btn.classList.add('active');
            });
          });

          getElements('.ws-instrument').forEach(input => {
            input.addEventListener('input', () => {
              const match = input.name.match(/^ws_instrument_(.+)_(\d+)$/);
              if (!match) return;
              const [, analyte, testId] = match;
              wsRecalculate(testId, analyte);

              // Update summary and statistics after individual test changes
              wsUpdateSummary();
            });
          });

          getElements('.ws-include').forEach(cb => {
            cb.addEventListener('change', () => {
              const match = cb.name.match(/^ws_include_(.+)_(\d+)$/);
              if (!match) return;
              const [, analyte, testId] = match;
              console.log(`Analyte: ${analyte} | TestId: ${testId}`)
              if (analyte === "all") return;

              // Recalculate the specific test/analyte and update summary
              wsRecalculate(testId, analyte);
              wsUpdateSummary();
            });
          });

          document.querySelectorAll('.ws-include-all').forEach(cb => {
            cb.addEventListener('change', () => {
              const match = cb.name.match(/^ws_include_all_(\d+)$/);
              if (!match) return;
              const [, testId] = match;
              const testIdStr = String(testId);
              const prefix = "ws_include_";
              const cbs = Array.from(document.querySelectorAll(`input[name^="${prefix}"]`))
                .filter(cb =>
                  cb.name.endsWith(`_${testIdStr}`) &&
                  cb.name !== `ws_include_all_${testIdStr}`
                );

              // Update all individual checkboxes and recalculate their tests
              cbs.forEach(childCb => {
                childCb.checked = cb.checked;
                const childMatch = childCb.name.match(/^ws_include_(.+)_(\d+)$/);
                if (childMatch) {
                  const [, analyte, testId] = childMatch;
                  if (analyte !== "all") {
                    wsRecalculate(testId, analyte);
                  }
                }
              });

              // Update summary once after all individual changes
              wsUpdateSummary();
            });
          });

          // Restore all user settings from saved data or initialize to defaults
          const settingsRestored = restoreUserSettings();

          // Update column visibility based on settings
          updateColumnVisibility();

          // Initialize table sorting
          initializeSorting();
          console.log("Table sorting initialized");

          // Initialize data integrity protection (without triggering updates)
          initializeDataIntegrityProtection();

          // Handle cancelled tests (disable include checkboxes and inputs)
          handleCancelledTests();

          // Initialize LOD display based on user settings
          toggleLodDisplay();

          // Initialize homogeneity tab based on settings and replicate count
          toggleHomogeneityTab();

          // Single comprehensive update at the end of initialization
          bulkUpdateResults();
          console.log("Initialization complete - performed single bulk update");
        }, 0);
      });

      // Remove the duplicate $(document).ready block
      function setupDataIntegrityUI() {
        // Set up data integrity UI without triggering updates
        // This is a placeholder for any UI setup that doesn't need immediate updates
      }

      // Multi-unit configuration storage (global)
      let selectedOutputUnits = [];

      // Helper function to escape unit names for use in element IDs and CSS selectors
      function escapeUnitForId(unit) {
        // Replace problematic characters with safe alternatives
        return unit.replace(/[^a-zA-Z0-9\-_]/g, function (char) {
          // Create a safe mapping for common characters
          const charMap = {
            '%': 'pct',
            '/': 'per',
            ' ': '_',
            '.': 'dot',
            '+': 'plus',
            '(': 'lparen',
            ')': 'rparen',
            '[': 'lbracket',
            ']': 'rbracket',
            '{': 'lbrace',
            '}': 'rbrace',
            ':': 'colon',
            ';': 'semicolon',
            '=': 'eq',
            '*': 'star',
            '&': 'amp',
            '<': 'lt',
            '>': 'gt',
            '?': 'q',
            '#': 'hash',
            '@': 'at',
            '!': 'excl',
            '$': 'dollar',
            '^': 'caret',
            '~': 'tilde',
            '`': 'backtick',
            '"': 'quote',
            "'": 'apos',
            '\\': 'bslash',
            '|': 'pipe'
          };
          return charMap[char] || 'x' + char.charCodeAt(0).toString(16);
        });
      }

      // Populate the sample information section
      function populateSampleInfoSection(sampleInfo, wsUnitConfig, allowedUnits, selectedOutputUnits, hasServingWeight, hasServingsPerPackage) {
        // Sample details (including assay name)
        getElementById("display-sample-id").textContent = sampleInfo.sample_id || "Not specified";
        getElementById("display-sample-name").textContent = sampleInfo.sample_name || "Not specified";
        getElementById("display-sample-type").textContent = sampleInfo.sample_type || "Not specified";
        getElementById("display-sample-qbn-id").textContent = sampleInfo.sample_qbn_id || "Not specified";
        getElementById("display-assay-name").textContent = wsUnitConfig.assay_display_name || wsUnitConfig.assay_name || "Not specified";

        // Product information
        const servingWeightElement = getElementById("display-serving-weight");
        if (hasServingWeight) {
          servingWeightElement.textContent = `${sampleInfo.serving_weight}g`;
          servingWeightElement.className = "sample-info-value available";
        } else {
          servingWeightElement.textContent = "Not specified";
          servingWeightElement.className = "sample-info-value missing";
        }

        const servingsPerPackageElement = getElementById("display-servings-per-package");
        if (hasServingsPerPackage) {
          servingsPerPackageElement.textContent = sampleInfo.servings_per_package;
          servingsPerPackageElement.className = "sample-info-value available";
        } else {
          servingsPerPackageElement.textContent = "Not specified";
          servingsPerPackageElement.className = "sample-info-value missing";
        }

        // Moisture content
        const moistureElement = getElementById("display-moisture-content");
        if (wsUnitConfig.moisture_found && wsUnitConfig.moisture_value > 0) {
          moistureElement.textContent = `${parseFloat(wsUnitConfig.moisture_value).toFixed(2)}%`;
          moistureElement.className = "sample-info-value available";
        } else {
          moistureElement.textContent = "Not available";
          moistureElement.className = "sample-info-value missing";
        }

        // Selected units
        getElementById("display-selected-units").textContent = selectedOutputUnits.join(", ");

        // Unit availability warning
        const warningElement = getElementById("unit-availability-warning");
        const warningTextElement = getElementById("unit-warning-text");

        const missingMgServing = !hasServingWeight && wsUnitConfig.allowed_units?.includes('mg/serving');
        const missingMgPackage = (!hasServingWeight || !hasServingsPerPackage) && wsUnitConfig.allowed_units?.includes('mg/package');

        if (missingMgServing || missingMgPackage) {
          let warningText = "Some units are unavailable: ";
          const unavailableUnits = [];

          if (missingMgServing) {
            unavailableUnits.push("mg/serving (requires serving weight)");
          }
          if (missingMgPackage) {
            const reason = !hasServingWeight ? "requires serving weight" : "requires servings per package";
            unavailableUnits.push(`mg/package (${reason})`);
          }

          warningText += unavailableUnits.join(", ");
          warningTextElement.textContent = warningText;
          warningElement.style.display = "block";
        } else {
          warningElement.style.display = "none";
        }
      }

      // Update the sample info section when units change
      function updateSampleInfoDisplay() {
        const selectedUnits = getSelectedOutputUnits();
        getElementById("display-selected-units").textContent = selectedUnits.join(", ");
      }

      // Initialize the multi-unit selector UI
      function initializeMultiUnitSelector(allowedUnits, initialSelection) {
        const container = getElementById("multi-unit-checkboxes");
        if (!container) {
          console.error("Multi-unit selector container not found");
          return;
        }

        container.innerHTML = ''; // Clear existing content

        allowedUnits.forEach(unit => {
          // Create checkbox container
          const checkboxItem = document.createElement('div');


          // Create checkbox
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = `output-unit-${escapeUnitForId(unit)}`;
          checkbox.value = unit;
          checkbox.checked = initialSelection.includes(unit);

          // Create label
          const label = document.createElement('label');
          label.htmlFor = `output-unit-${escapeUnitForId(unit)}`;
          label.textContent = unit;

          // Add event listener
          checkbox.addEventListener('change', (e) => {
            handleUnitCheckboxChange(unit, e.target.checked);
          });

          // Assemble the UI
          checkboxItem.appendChild(checkbox);
          checkboxItem.appendChild(label);
          container.appendChild(checkboxItem);
        });
      }

      // Handle unit checkbox change events
      function handleUnitCheckboxChange(unit, isChecked) {
        if (isChecked) {
          addOutputUnit(unit);
        } else {
          const removed = removeOutputUnit(unit);
          if (!removed) {
            // If removal failed (e.g., last unit), reset the checkbox
            const checkbox = getElementById(`output-unit-${escapeUnitForId(unit)}`);
            if (checkbox) {
              checkbox.checked = true;
            }
            alert("At least one output unit must be selected.");
            return; // Don't update anything if removal failed
          }
        }

        // Update display unit selector options (skip bulk update since we'll do it below)
        updateDisplayUnitSelector(true);

        // Update sample info display with new selected units
        updateSampleInfoDisplay();

        // Rebuild table structure with new unit columns
        rebuildTableForMultiUnit();

        // Note: wsGenerateFinalResults() is called by rebuildTableForMultiUnit() -> bulkUpdateResults() -> wsUpdateSummary()
        // No need to call it again here
      }

      // Update the multi-unit selector UI to reflect current selection
      function updateMultiUnitSelector() {
        const currentSelection = getSelectedOutputUnits();
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const allowedUnits = wsUnitConfig.allowed_units || ['ppb'];

        allowedUnits.forEach(unit => {
          const checkbox = getElementById(`output-unit-${escapeUnitForId(unit)}`);
          if (checkbox) {
            checkbox.checked = currentSelection.includes(unit);
          }
        });
      }

      // Multi-unit configuration management
      function getSelectedOutputUnits() {
        // Return the current selected output units
        return selectedOutputUnits || [];
      }

      function setSelectedOutputUnits(units) {
        // Validate and set selected output units
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const allowedUnits = wsUnitConfig.allowed_units || ['ppb'];

        // Filter to only valid units
        const validUnits = units.filter(unit => allowedUnits.includes(unit));

        // Ensure at least one unit is selected
        if (validUnits.length === 0) {
          console.warn("Cannot set empty unit selection, keeping current selection");
          return false;
        }

        selectedOutputUnits = [...validUnits];
        console.log("Selected output units updated:", selectedOutputUnits);

        // Update the UI to reflect the new selection
        updateMultiUnitSelector();
        updateDisplayUnitSelector();

        return true;
      }

      function addOutputUnit(unit) {
        // Add a unit to the selected output units
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const allowedUnits = wsUnitConfig.allowed_units || ['ppb'];

        if (!allowedUnits.includes(unit)) {
          console.warn("Cannot add invalid unit:", unit);
          return false;
        }

        if (!selectedOutputUnits.includes(unit)) {
          selectedOutputUnits.push(unit);
          console.log("Added output unit:", unit, "Current selection:", selectedOutputUnits);
        }
        return true;
      }

      function removeOutputUnit(unit) {
        // Remove a unit from selected output units (with minimum validation)
        if (selectedOutputUnits.length <= 1) {
          console.warn("Cannot remove last remaining output unit");
          return false;
        }

        const index = selectedOutputUnits.indexOf(unit);
        if (index > -1) {
          selectedOutputUnits.splice(index, 1);
          console.log("Removed output unit:", unit, "Current selection:", selectedOutputUnits);
          return true;
        }
        return false;
      }

      function isOutputUnitSelected(unit) {
        // Check if a unit is currently selected for output
        return selectedOutputUnits.includes(unit);
      }

      // Display unit management for table headers and display
      let currentDisplayUnit = 'ppb'; // Fallback - will be properly set during initialization

      function initializeDisplayUnitSelector(allowedUnits, defaultUnit) {
        const selector = getElementById("display-unit-selector");
        if (!selector) {
          console.error("Display unit selector not found");
          return;
        }

        selector.innerHTML = ''; // Clear existing options

        allowedUnits.forEach(unit => {
          const option = document.createElement('option');
          option.value = unit;
          option.textContent = unit;
          option.selected = unit === defaultUnit;
          selector.appendChild(option);
        });

        // Set current display unit
        currentDisplayUnit = defaultUnit;

        // Add event listener
        selector.addEventListener('change', (e) => {
          handleDisplayUnitChange(e.target.value);
        });
      }

      function updateDisplayUnitSelector(skipBulkUpdate = false) {
        const selector = getElementById("display-unit-selector");
        if (!selector) {
          console.error("Display unit selector not found");
          return;
        }

        const selectedUnits = getSelectedOutputUnits();

        // Clear existing options
        selector.innerHTML = '';

        // Add options for all selected output units
        selectedUnits.forEach(unit => {
          const option = document.createElement('option');
          option.value = unit;
          option.textContent = unit;
          option.selected = unit === currentDisplayUnit;
          selector.appendChild(option);
        });

        // If current display unit is no longer selected, switch to first available
        if (!selectedUnits.includes(currentDisplayUnit)) {
          currentDisplayUnit = selectedUnits[0];
          selector.value = currentDisplayUnit;
          updateHeaders(currentDisplayUnit);

          // Only call bulkUpdateResults if we're not skipping it (i.e., this is a standalone call)
          if (!skipBulkUpdate) {
            bulkUpdateResults();
          }
        }
      }

      function handleDisplayUnitChange(newDisplayUnit) {
        currentDisplayUnit = newDisplayUnit;
        console.log("Display unit changed to:", newDisplayUnit);

        // Update headers
        updateHeaders(currentDisplayUnit);

        // Recalculate and update all displays
        bulkUpdateResults();
      }

      function getCurrentDisplayUnit() {
        return currentDisplayUnit;
      }

      // Check if compliance mode is enabled
      function isComplianceMode() {
        const complianceCheckbox = getElementById("compliance-checkbox");
        return complianceCheckbox ? complianceCheckbox.checked : true; // Default to true if checkbox not found
      }

      // Check if uncertainty mode is enabled
      function isUncertaintyMode() {
        const uncertaintyCheckbox = getElementById("uncertainty-checkbox");
        return uncertaintyCheckbox ? uncertaintyCheckbox.checked : false; // Default to false if checkbox not found
      }

      // Check if LOD display is enabled
      function isLodDisplayEnabled() {
        const lodCheckbox = getElementById("lod-display-enabled");
        return lodCheckbox ? lodCheckbox.checked : true; // Default to true if checkbox not found
      }

      // Function to toggle LOD column visibility
      function toggleLodDisplay(showLod) {
        // If no parameter provided, get current state from checkbox
        if (showLod === undefined) {
          showLod = isLodDisplayEnabled();
        }
        // Update all LOD headers
        const lodHeaders = getElementsByName("lod-header");
        lodHeaders.forEach(header => {
          header.style.display = showLod ? '' : 'none';
        });

        // Update all LOD cells in test tables
        const lodCells = document.querySelectorAll('.ws-lod');
        lodCells.forEach(cell => {
          cell.style.display = showLod ? '' : 'none';
        });

        // Update summary LOD cells
        const summaryLodCells = document.querySelectorAll('.ws-summary-lod');
        summaryLodCells.forEach(cell => {
          cell.style.display = showLod ? '' : 'none';
        });

        // Update statistics tables if they have LOD columns
        const statsLodCells = document.querySelectorAll('.ws-stats-lod, [name="stats-lod-header"]');
        statsLodCells.forEach(cell => {
          cell.style.display = showLod ? '' : 'none';
        });

        console.log(`LOD column display ${showLod ? 'enabled' : 'disabled'}`);
      }

      // Check if homogeneity analysis is enabled
      function isHomogeneityEnabled() {
        const homogeneityCheckbox = getElementById("homogeneity-enabled");
        return homogeneityCheckbox ? homogeneityCheckbox.checked : false;
      }

      // Check if minimum replicates requirement is met for homogeneity
      function hasMinimumReplicatesForHomogeneity() {
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const minReplicates = wsUnitConfig.homogeneity_min_replicates || 5;

        // Count total number of tests (excluding cancelled ones)
        const testCount = getElements('[id^="ws-tab-"]:not(#ws-tab-summary):not(#ws-tab-statistics):not(#ws-tab-settings):not(#ws-tab-sample-info):not(#ws-tab-homogeneity)').length;

        return testCount >= minReplicates;
      }

      // Toggle homogeneity tab visibility based on settings
      function toggleHomogeneityTab() {
        const homogeneityTab = document.querySelector('[data-ws-tab="homogeneity"]');
        const homogeneityContent = getElementById("ws-tab-homogeneity");
        const homogeneityCheckbox = getElementById("homogeneity-enabled");

        const hasMinReplicates = hasMinimumReplicatesForHomogeneity();
        const isEnabled = isHomogeneityEnabled();

        if (!homogeneityCheckbox) return;

        // Disable checkbox if not enough replicates
        if (!hasMinReplicates) {
          homogeneityCheckbox.disabled = true;
          homogeneityCheckbox.checked = false;

          // Update label to show why it's disabled
          const label = document.querySelector('label[for="homogeneity-enabled"]');
          if (label) {
            const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
            const minReplicates = wsUnitConfig.homogeneity_min_replicates || 5;
            const currentCount = getElements('[id^="ws-tab-"]:not(#ws-tab-summary):not(#ws-tab-statistics):not(#ws-tab-settings):not(#ws-tab-sample-info):not(#ws-tab-homogeneity)').length;

            label.style.color = '#999';
            label.title = `Homogeneity analysis requires at least ${minReplicates} replicates. Current count: ${currentCount}`;
          }
        } else {
          // Re-enable checkbox if enough replicates
          homogeneityCheckbox.disabled = false;

          // Restore label styling
          const label = document.querySelector('label[for="homogeneity-enabled"]');
          if (label) {
            label.style.color = '';
            label.title = '';
          }
        }

        // Show/hide tab based on enabled state and minimum replicates
        const shouldShow = isEnabled && hasMinReplicates;

        if (homogeneityTab && homogeneityContent) {
          homogeneityTab.style.display = shouldShow ? '' : 'none';

          if (shouldShow) {
            console.log("Showing homogeneity tab - generating table");
            generateHomogeneityTable();
          } else {
            console.log("Hiding homogeneity tab - requirements not met");
            // Clear content if hiding
            const contentDiv = getElementById("homogeneity-content");
            if (contentDiv) {
              contentDiv.innerHTML = `
                    <p style="text-align: center; color: #999; font-style: italic;">
                        ${!isEnabled ?
                  'Homogeneity analysis is disabled. Enable in Settings to analyze replicate variation.' :
                  `Insufficient replicates for homogeneity analysis. Minimum ${JSON.parse(getElementById("ws-unit-config")?.textContent || "{}").homogeneity_min_replicates || 5} tests required.`
                }
                    </p>
                `;
            }
          }
        }

        // Persist settings changes
        bulkUpdateResults();
      }

      // Generate the homogeneity analysis table
      function generateHomogeneityTable() {
        const tableContainer = getElementById("homogeneity-table-container");
        const placeholder = getElementById("homogeneity-placeholder");

        if (!tableContainer || !placeholder) return;

        // Show table, hide placeholder
        tableContainer.style.display = 'block';
        placeholder.style.display = 'none';

        // Get configuration
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const displayUnit = getCurrentDisplayUnit();
        const sigFigsInput = getElementById("sig-fig-input")?.value;
        const sigFigs = sigFigsInput !== '' && sigFigsInput !== null ? parseInt(sigFigsInput) : 3;

        // Get all analytes from the table rows
        const analyteRows = document.querySelectorAll('#homogeneity-table-body tr[data-analyte]');

        analyteRows.forEach(row => {
          const analyte = row.getAttribute('data-analyte');

          // Check if this analyte is included in homogeneity analysis
          const includeCheckbox = row.querySelector('.ws-homogeneity-include');
          if (!includeCheckbox || !includeCheckbox.checked) {
            // Clear all data for excluded analytes
            const meanCell = row.querySelector('.hom-mean');
            const valueCell = row.querySelector('.hom-value');
            const limitCell = row.querySelector('.hom-limit');
            const statusCell = row.querySelector('.hom-status');

            if (meanCell) meanCell.textContent = '-';
            if (valueCell) valueCell.textContent = '-';
            if (limitCell) limitCell.textContent = '-';
            if (statusCell) {
              statusCell.textContent = '-';
              statusCell.className = 'hom-status';
              statusCell.style.color = '#6c757d';
            }

            // Clear individual test cells
            const individualCells = row.querySelectorAll('.hom-individual');
            individualCells.forEach(cell => {
              cell.textContent = '-';
              cell.style.color = '';
            });
            return;
          }

          // Get analyte-specific homogeneity limit from kvstore
          const analyteHomogeneityLimit = wsUnitConfig[`${analyte}_homogeneity_limit`] || 0.25; // Default 25%

          // Get all values for this analyte from included tests
          const values = [];
          const testData = [];

          // Collect data from all test tabs and handle both included and excluded tests
          const includeCheckboxes = document.querySelectorAll(`input[name^="ws_include_${analyte}_"]`);
          includeCheckboxes.forEach(checkbox => {
            const testId = checkbox.name.split('_').pop();
            const individualCell = row.querySelector(`[name="hom_individual_${analyte}_${testId}"]`);

            if (!checkbox.checked) {
              // Clear excluded test cells
              if (individualCell) {
                individualCell.textContent = '-';
                individualCell.style.color = '';
              }
              return;
            }

            const resultCell = document.querySelector(`[name="ws_final_${analyte}_${testId}_${displayUnit}"]`) ||
              document.querySelector(`[name="ws_final_${analyte}_${testId}"]`);

            if (resultCell && resultCell.textContent !== "NT") {
              const cellText = resultCell.textContent.trim();

              // Handle special values
              let value = null;
              if (cellText === "ND" || cellText === "<LOQ" || cellText.startsWith("<")) {
                value = 0; // Treat non-detects as zero for homogeneity calculation
              } else {
                value = parseFloat(cellText);
              }

              if (value !== null && !isNaN(value)) {
                values.push(value);
                testData.push({ testId, value, originalText: cellText });
              }
            }
          });

          // Get minimum replicates required for homogeneity analysis
          const minReplicates = wsUnitConfig.homogeneity_min_replicates || 5;

          // Calculate homogeneity if we have enough data
          if (values.length >= minReplicates) {
            const mean = values.reduce((sum, val) => sum + val, 0) / values.length;

            // Calculate homogeneity value (max deviation from mean)
            let homogeneityValue = 0;
            if (mean === 0) {
              // If mean is zero, homogeneity should be 0% (all values are essentially the same)
              homogeneityValue = 0;
            } else {
              homogeneityValue = Math.max(...values.map(val => Math.abs((val - mean) / mean)));
            }

            const status = homogeneityValue <= analyteHomogeneityLimit ? 'PASS' : 'FAIL';

            // Update the row data
            const meanCell = row.querySelector('.hom-mean');
            const valueCell = row.querySelector('.hom-value');
            const limitCell = row.querySelector('.hom-limit');
            const statusCell = row.querySelector('.hom-status');

            if (meanCell) meanCell.textContent = mean.toFixed(sigFigs);
            if (valueCell) valueCell.textContent = (homogeneityValue * 100).toFixed(2) + '%';
            if (limitCell) limitCell.textContent = (analyteHomogeneityLimit * 100).toFixed(1) + '%';
            if (statusCell) {
              statusCell.textContent = status;
              statusCell.className = `hom-status ${status === 'PASS' ? 'hom-status-pass' : 'hom-status-fail'}`;
            }

            // Update individual test cells
            testData.forEach(({ testId, value, originalText }) => {
              const individualCell = row.querySelector(`[name="hom_individual_${analyte}_${testId}"]`);
              if (individualCell) {
                let deviation = 0;
                if (mean === 0) {
                  // If mean is zero, show 0% deviation for all values
                  deviation = 0;
                } else {
                  deviation = (value - mean) / mean;
                }

                // Show original text for special values in parentheses
                let displayText = (deviation * 100).toFixed(2) + '%';
                if (originalText === "ND" || originalText === "<LOQ" || originalText.startsWith("<")) {
                  displayText += ` (${originalText})`;
                }

                individualCell.textContent = displayText;

                // Color code the cell based on deviation
                if (Math.abs(deviation) <= analyteHomogeneityLimit) {
                  individualCell.style.color = '#28a745'; // Green for within limits
                } else {
                  individualCell.style.color = '#dc3545'; // Red for outside limits
                }
              }
            });

          } else {
            // Insufficient data - still show calculations but mark status as N/A
            const meanCell = row.querySelector('.hom-mean');
            const valueCell = row.querySelector('.hom-value');
            const limitCell = row.querySelector('.hom-limit');
            const statusCell = row.querySelector('.hom-status');

            // Still calculate and show mean and homogeneity values if we have at least 2 points
            if (values.length >= 2) {
              const mean = values.reduce((sum, val) => sum + val, 0) / values.length;

              // Calculate homogeneity value (max deviation from mean)
              let homogeneityValue = 0;
              if (mean === 0) {
                homogeneityValue = 0;
              } else {
                homogeneityValue = Math.max(...values.map(val => Math.abs((val - mean) / mean)));
              }

              if (meanCell) meanCell.textContent = mean.toFixed(sigFigs);
              if (valueCell) valueCell.textContent = (homogeneityValue * 100).toFixed(2) + '%';

              // Update individual test cells
              testData.forEach(({ testId, value, originalText }) => {
                const individualCell = row.querySelector(`[name="hom_individual_${analyte}_${testId}"]`);
                if (individualCell) {
                  let deviation = 0;
                  if (mean === 0) {
                    deviation = 0;
                  } else {
                    deviation = (value - mean) / mean;
                  }

                  let displayText = (deviation * 100).toFixed(2) + '%';
                  if (originalText === "ND" || originalText === "<LOQ" || originalText.startsWith("<")) {
                    displayText += ` (${originalText})`;
                  }

                  individualCell.textContent = displayText;
                  // Color code normally
                  if (Math.abs(deviation) <= analyteHomogeneityLimit) {
                    individualCell.style.color = '#28a745';
                  } else {
                    individualCell.style.color = '#dc3545';
                  }
                }
              });
            } else {
              // Less than 2 points - still show actual values but status N/A
              if (values.length === 1) {
                // With 1 point, show the mean (which is that point) and 0% homogeneity
                const mean = values[0];
                if (meanCell) meanCell.textContent = mean.toFixed(sigFigs);
                if (valueCell) valueCell.textContent = '0.00%'; // No variation with 1 point

                // Update the one included test cell
                testData.forEach(({ testId, originalText }) => {
                  const individualCell = row.querySelector(`[name="hom_individual_${analyte}_${testId}"]`);
                  if (individualCell) {
                    let displayText = '0.00%'; // No deviation from itself
                    if (originalText === "ND" || originalText === "<LOQ" || originalText.startsWith("<")) {
                      displayText += ` (${originalText})`;
                    }
                    individualCell.textContent = displayText;
                    individualCell.style.color = '#28a745'; // Green since 0% is within limits
                  }
                });
              } else {
                // 0 points - can't calculate anything
                if (meanCell) meanCell.textContent = 'N/A';
                if (valueCell) valueCell.textContent = 'N/A';

                // Don't clear all cells - excluded cells were already cleared above
                // Only update included test cells to N/A if there are any
                testData.forEach(({ testId }) => {
                  const individualCell = row.querySelector(`[name="hom_individual_${analyte}_${testId}"]`);
                  if (individualCell) {
                    individualCell.textContent = 'N/A';
                    individualCell.style.color = '#6c757d';
                  }
                });
              }
            }

            // Always show limit and set status to N/A for insufficient replicates
            if (limitCell) limitCell.textContent = (analyteHomogeneityLimit * 100).toFixed(1) + '%';
            if (statusCell) {
              statusCell.textContent = 'N/A';
              statusCell.className = 'hom-status';
              statusCell.style.color = '#6c757d';
              statusCell.title = `Insufficient replicates: ${values.length} valid point(s), minimum ${minReplicates} required for valid homogeneity assessment`;
            }
          }
        });

        // Update the "Include All" checkbox state after generating the table
        updateHomogeneityIncludeAllCheckbox();

        // Update the homogeneity summary column after generating the table
        updateHomogeneitySummaryColumn();

        console.log("Homogeneity table populated");
      }

      // Helper function to get homogeneity status for a specific analyte
      function getAnalyteHomogeneityStatus(analyte) {
        if (!isHomogeneityEnabled() || !hasMinimumReplicatesForHomogeneity()) {
          return 'N/A';
        }

        const statusCell = document.querySelector(`[name="hom_status_${analyte}"]`);
        return statusCell ? statusCell.textContent : 'N/A';
      }

      // Helper function to get overall homogeneity status
      function getHomogeneityStatus() {
        if (!isHomogeneityEnabled() || !hasMinimumReplicatesForHomogeneity()) {
          return 'N/A';
        }

        const statusCells = document.querySelectorAll('.hom-status');
        let hasPass = false;
        let hasFail = false;

        statusCells.forEach(cell => {
          const status = cell.textContent;
          if (status === 'PASS') hasPass = true;
          if (status === 'FAIL') hasFail = true;
        });

        if (hasFail) return 'FAIL';
        if (hasPass) return 'PASS';
        return 'N/A';
      }

      // Helper function to update the "Include All" checkbox state
      function updateHomogeneityIncludeAllCheckbox() {
        const includeAllCheckbox = document.querySelector('.ws-homogeneity-include-all');
        const individualCheckboxes = document.querySelectorAll('.ws-homogeneity-include');

        if (!includeAllCheckbox || individualCheckboxes.length === 0) return;

        const checkedCount = Array.from(individualCheckboxes).filter(cb => cb.checked).length;
        const totalCount = individualCheckboxes.length;

        if (checkedCount === 0) {
          // None checked
          includeAllCheckbox.checked = false;
          includeAllCheckbox.indeterminate = false;
        } else if (checkedCount === totalCount) {
          // All checked
          includeAllCheckbox.checked = true;
          includeAllCheckbox.indeterminate = false;
        } else {
          // Some checked
          includeAllCheckbox.checked = false;
          includeAllCheckbox.indeterminate = true;
        }
      }

      // Rebuild table headers with multiple Final Result columns
      function rebuildTableHeaders() {
        const selectedUnits = getSelectedOutputUnits();
        const displayUnit = getCurrentDisplayUnit();

        // Find all table headers that need to be updated
        const tableHeaders = getElements('thead tr');

        tableHeaders.forEach(headerRow => {
          // Check if this is a summary table or test table
          const summaryTable = headerRow.closest('#ws-tab-summary');
          const testTable = headerRow.closest('[id^="ws-tab-"]:not(#ws-tab-summary):not(#ws-tab-statistics):not(#ws-tab-settings):not(#ws-tab-sample-info):not(#ws-tab-homogeneity)');

          if (summaryTable) {
            // Handle summary table - rebuild with multi-unit columns
            rebuildSummaryTableHeaders(headerRow, selectedUnits);
          } else if (testTable) {
            // Handle test table - rebuild with multi-unit columns  
            rebuildTestTableHeaders(headerRow, selectedUnits);
          }
        });
      }

      function rebuildSummaryTableHeaders(headerRow, selectedUnits) {
        // Find the position of the result header
        const resultHeader = headerRow.querySelector('[name="final-header"]') ||
          headerRow.querySelector('th:nth-child(4)'); // Result column
        if (!resultHeader) return;

        // Remove all existing result headers
        const existingResultHeaders = headerRow.querySelectorAll('[name^="final-header"]');
        existingResultHeaders.forEach(header => header.remove());

        // Find the position where to insert new headers (before limit-header)
        const limitHeader = headerRow.querySelector('[name="limit-header"]') ||
          headerRow.querySelector('th:nth-child(5)'); // Limit column

        // Create new result headers for each selected unit
        selectedUnits.forEach((unit, index) => {
          const newHeader = document.createElement('th');
          newHeader.setAttribute('name', `final-header-${unit}`);
          newHeader.setAttribute('class', 'summary-sortable');
          newHeader.textContent = `Result (${unit})`;

          // Insert before the limit header
          if (limitHeader) {
            headerRow.insertBefore(newHeader, limitHeader);
          } else {
            headerRow.appendChild(newHeader);
          }
        });
      }

      function rebuildTestTableHeaders(headerRow, selectedUnits) {
        // Find the position of the final-header
        const finalHeader = headerRow.querySelector('[name="final-header"]') ||
          headerRow.querySelector('th:nth-child(6)'); // Result column;
        if (!finalHeader) return;

        // Remove all existing final result headers (more thorough cleanup)
        const existingFinalHeaders = headerRow.querySelectorAll('[name^="final-header"]');
        existingFinalHeaders.forEach(header => header.remove());

        // Find the position where to insert new headers (before limit-header)
        const limitHeader = headerRow.querySelector('[name="limit-header"]') ||
          headerRow.querySelector('th:nth-child(7)'); // Limit column;

        // Create new final result headers for each selected unit
        selectedUnits.forEach((unit, index) => {
          const newHeader = document.createElement('th');
          newHeader.setAttribute('name', `final-header-${unit}`);
          newHeader.setAttribute('class', 'test-sortable');
          newHeader.setAttribute('data-column', `4-${index}`);
          newHeader.textContent = `Final Result (${unit})`;

          // Insert before the limit header
          if (limitHeader) {
            headerRow.insertBefore(newHeader, limitHeader);
          } else {
            headerRow.appendChild(newHeader);
          }
        });
      }

      // Rebuild table rows with multiple Final Result columns
      function rebuildTableRows() {
        const selectedUnits = getSelectedOutputUnits();

        // Find summary table rows
        const summaryRows = getElements('#ws-summary-body tr[data-ws-analyte]');
        summaryRows.forEach(row => rebuildSummaryTableRow(row, selectedUnits));

        // Find test table rows - look in all test tabs for rows with analyte data
        const testRows = getElements('tr[data-ws-analyte][data-ws-test]');
        console.log("Found", testRows.length, "test rows");
        testRows.forEach(row => rebuildTestTableRow(row, selectedUnits));
      }

      function rebuildSummaryTableRow(row, selectedUnits) {
        // Remove all existing result cells (but keep other cells)
        const existingResultCells = row.querySelectorAll('[name^="ws_mean_"]');
        existingResultCells.forEach(cell => cell.remove());

        // Find the position where to insert new cells (before limit cell)
        const limitCell = row.querySelector('.ws-summary-limit');
        const analyte = row.getAttribute('data-ws-analyte');

        // Create new result cells for each selected unit
        selectedUnits.forEach(unit => {
          const newCell = document.createElement('td');
          newCell.setAttribute('class', 'ws-summary-mean');
          newCell.setAttribute('name', `ws_mean_${analyte}_${unit}`);
          newCell.setAttribute('data-unit', unit);
          newCell.textContent = 'NT';

          // Insert before the limit cell
          if (limitCell) {
            row.insertBefore(newCell, limitCell);
          } else {
            row.appendChild(newCell);
          }
        });
      }

      function rebuildTestTableRow(row, selectedUnits) {
        // Remove all existing final result cells
        const existingFinalCells = row.querySelectorAll('[name^="ws_final_"]');
        existingFinalCells.forEach(cell => cell.remove());

        // Find the position where to insert new cells (before ws-limit)
        const limitCell = row.querySelector('.ws-limit');

        // Get analyte and test info from the row
        const analyte = row.getAttribute('data-ws-analyte');
        const testId = row.getAttribute('data-ws-test');

        // Create new final result cells for each selected unit
        selectedUnits.forEach(unit => {
          const newCell = document.createElement('td');
          newCell.setAttribute('class', 'ws-final');
          newCell.setAttribute('name', `ws_final_${analyte}_${testId}_${unit}`);
          newCell.setAttribute('data-unit', unit);
          newCell.textContent = 'NT';

          // Insert before the limit cell
          if (limitCell) {
            row.insertBefore(newCell, limitCell);
          } else {
            row.appendChild(newCell);
          }
        });
      }

      // Main function to rebuild tables for multi-unit output
      function rebuildTableForMultiUnit() {
        console.log("Rebuilding tables for multi-unit output");

        // First rebuild headers to accommodate multiple unit columns
        rebuildTableHeaders();

        // Then rebuild rows to match the new header structure
        rebuildTableRows();

        // Recalculate all results with the new table structure
        bulkUpdateResults();

        console.log("Table rebuild complete");
      }

      function applyDataProtection(enable) {
        // Protect instrument result inputs
        const instrumentInputs = document.querySelectorAll('.ws-instrument');
        instrumentInputs.forEach(input => {
          if (enable) {
            input.readOnly = true;
            input.classList.add('data-locked');
            input.title = "Field is locked for data integrity. Click 'Request Data Unlock' to modify.";
          } else {
            input.readOnly = false;
            input.classList.remove('data-locked');
            input.title = "Field is unlocked for editing - deviation logged.";
          }
        });

        // Protect include checkboxes
        // Clear existing options
        selector.innerHTML = '';

        // Add options for all selected output units
        selectedUnits.forEach(unit => {
          const option = document.createElement('option');
          option.value = unit;
          option.textContent = unit;
          option.selected = unit === currentDisplayUnit;
          selector.appendChild(option);
        });

        // If current display unit is no longer selected, switch to first available
        if (!selectedUnits.includes(currentDisplayUnit)) {
          currentDisplayUnit = selectedUnits[0];
          selector.value = currentDisplayUnit;
          updateHeaders(currentDisplayUnit);

          // Only call bulkUpdateResults if we're not skipping it (i.e., this is a standalone call)
          if (!skipBulkUpdate) {
            bulkUpdateResults();
          }
        }
      }

      // Data Integrity Protection System
      let dataIntegrityState = {
        isLocked: true,
        deviations: [],
        currentDeviation: null
      };

      function initializeDataIntegrityProtection() {
        // Load existing deviations from storage
        loadExistingDeviations();

        // Apply protection by default
        applyDataProtection(true);

        // Setup event handlers
        getElementById('data-protection-enabled').addEventListener('change', function () {
          if (this.checked) {
            applyDataProtection(true);
            dataIntegrityState.isLocked = true;
          } else {
            applyDataProtection(false);
            dataIntegrityState.isLocked = false;
          }
          updateProtectionUI();
        });

        getElementById('unlock-data-btn').addEventListener('click', function () {
          if (dataIntegrityState.isLocked) {
            showDeviationModal();
          }
        });

        getElementById('lock-data-btn').addEventListener('click', function () {
          // Log the re-locking if there was an active deviation
          if (dataIntegrityState.currentDeviation && !dataIntegrityState.isLocked) {
            dataIntegrityState.currentDeviation.relockTime = new Date().toISOString();
            dataIntegrityState.currentDeviation = null;
            updateDeviationStorage();
          }

          applyDataProtection(true);
          dataIntegrityState.isLocked = true;
          updateProtectionUI();
          console.log("Data protection re-enabled");
        });

        // Setup deviation modal handlers
        setupDeviationModal();

        // Setup deviation review modal handlers
        setupDeviationReviewModal();

        console.log("Data integrity protection initialized");
      }

      function loadExistingDeviations() {
        const deviationField = getDeviationField();
        if (deviationField && deviationField.value) {
          try {
            dataIntegrityState.deviations = JSON.parse(deviationField.value) || [];
            // Find the most recent deviation if data is currently unlocked
            if (dataIntegrityState.deviations.length > 0 && !dataIntegrityState.isLocked) {
              dataIntegrityState.currentDeviation = dataIntegrityState.deviations[dataIntegrityState.deviations.length - 1];
            }
          } catch (e) {
            console.warn('Failed to load existing deviations:', e);
            dataIntegrityState.deviations = [];
          }
        }

        // Ensure UI is updated after loading
        updateProtectionUI();
      }

      function applyDataProtection(enable) {
        // Protect instrument result inputs
        const instrumentInputs = document.querySelectorAll('.ws-instrument');
        instrumentInputs.forEach(input => {
          if (enable) {
            input.readOnly = true;
            input.classList.add('data-locked');
            input.title = "Field is locked for data integrity. Click 'Request Data Unlock' to modify.";
          } else {
            input.readOnly = false;
            input.classList.remove('data-locked');
            input.title = "Field is unlocked for editing - deviation logged.";
          }
        });

        // Protect include checkboxes
        const includeCheckboxes = document.querySelectorAll('.ws-include, .ws-include-all');
        includeCheckboxes.forEach(checkbox => {
          if (enable) {
            checkbox.disabled = true;
            checkbox.classList.add('data-locked');
            checkbox.title = "Checkbox is locked for data integrity. Excluding analytes requires deviation logging.";
          } else {
            checkbox.disabled = false;
            checkbox.classList.remove('data-locked');
            checkbox.title = "Checkbox is unlocked - deviation logged for analyte inclusion changes.";
          }
        });

        // Also apply to any future inputs (if dynamically added)
        const observer = new MutationObserver(function (mutations) {
          if (enable) {
            mutations.forEach(function (mutation) {
              mutation.addedNodes.forEach(function (node) {
                if (node.nodeType === 1) {
                  // Apply protection to any new instrument inputs
                  const newInputs = node.querySelectorAll ? node.querySelectorAll('.ws-instrument') : [];
                  newInputs.forEach(input => {
                    input.readOnly = true;
                    input.classList.add('data-locked');
                    input.title = "Field is locked for data integrity. Click 'Request Data Unlock' to modify.";
                  });

                  // Apply protection to any new checkboxes
                  const newCheckboxes = node.querySelectorAll ? node.querySelectorAll('.ws-include, .ws-include-all') : [];
                  newCheckboxes.forEach(checkbox => {
                    checkbox.disabled = true;
                    checkbox.classList.add('data-locked');
                    checkbox.title = "Checkbox is locked for data integrity. Excluding analytes requires deviation logging.";
                  });
                }
              });
            });
          }
        });

        // Add click handlers for locked field warnings
        if (enable) {
          instrumentInputs.forEach(input => {
            input.addEventListener('click', handleLockedFieldClick);
          });
          includeCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('click', handleLockedCheckboxClick);
          });
        } else {
          instrumentInputs.forEach(input => {
            input.removeEventListener('click', handleLockedFieldClick);
          });
          includeCheckboxes.forEach(checkbox => {
            checkbox.removeEventListener('click', handleLockedCheckboxClick);
          });
        }

        // Only observe when protection is enabled
        if (enable) {
          observer.observe(document.body, { childList: true, subtree: true });
        }
      }

      function handleLockedFieldClick(e) {
        if (e.target.readOnly && e.target.classList.contains('data-locked')) {
          e.preventDefault();
          const proceed = confirm(
            "⚠️ DATA INTEGRITY PROTECTION ACTIVE\n\n" +
            "This field contains instrument data and is protected from unauthorized changes.\n\n" +
            "To edit this field, you must log a deviation explaining why manual entry is necessary.\n\n" +
            "Would you like to request data unlock permission?"
          );

          if (proceed) {
            showDeviationModal();
          }
        }
      }

      function handleLockedCheckboxClick(e) {
        if (e.target.disabled && e.target.classList.contains('data-locked')) {
          e.preventDefault();
          e.stopPropagation();

          const isIncludeAll = e.target.classList.contains('ws-include-all');
          const checkboxType = isIncludeAll ? "bulk selection" : "individual analyte inclusion";

          const proceed = confirm(
            "⚠️ DATA INTEGRITY PROTECTION ACTIVE\n\n" +
            `This ${checkboxType} checkbox is protected to prevent unauthorized exclusion of analytes from calculations.\n\n` +
            "Excluding analytes can affect:\n" +
            "• RSD calculations and statistics\n" +
            "• Sample compliance status\n" +
            "• Reporting accuracy\n\n" +
            "To modify analyte inclusion, you must log a deviation explaining the scientific justification.\n\n" +
            "Would you like to request data unlock permission?"
          );

          if (proceed) {
            showDeviationModal();
          }

          return false;
        }
      }

      function updateProtectionUI() {
        const statusBadge = document.getElementById('protection-status');
        const lockBtn = document.getElementById('lock-data-btn');
        const unlockBtn = document.getElementById('unlock-data-btn');
        const protectionCheckbox = document.getElementById('data-protection-enabled');

        if (dataIntegrityState.isLocked) {
          statusBadge.textContent = 'LOCKED';
          statusBadge.className = 'protection-status locked';
          lockBtn.disabled = true;
          unlockBtn.disabled = false;
          protectionCheckbox.checked = true;
        } else {
          statusBadge.textContent = 'UNLOCKED';
          statusBadge.className = 'protection-status unlocked';
          lockBtn.disabled = false;
          unlockBtn.disabled = true;
          protectionCheckbox.checked = false;
        }

        updateDeviationSummary();
      }

      function showDeviationModal() {
        document.getElementById('deviation-modal').style.display = 'block';
        // Clear previous form data
        document.getElementById('deviation-form').reset();
      }

      function hideDeviationModal() {
        document.getElementById('deviation-modal').style.display = 'none';
      }

      function setupDeviationModal() {
        // Close button
        getElement('.deviation-close').addEventListener('click', hideDeviationModal);

        // Cancel button
        document.getElementById('cancel-deviation').addEventListener('click', hideDeviationModal);

        // Click outside modal to close
        window.addEventListener('click', function (event) {
          const modal = document.getElementById('deviation-modal');
          if (event.target === modal) {
            hideDeviationModal();
          }
        });

        // Form submission
        document.getElementById('deviation-form').addEventListener('submit', function (e) {
          e.preventDefault();
          handleDeviationSubmission();
        });
      }

      function setupDeviationReviewModal() {
        // Review Deviations button
        const reviewBtn = document.getElementById('review-deviations-btn');
        if (reviewBtn) {
          reviewBtn.addEventListener('click', showDeviationReview);
        }

        // Close button
        const closeBtn = getElement('.deviation-review-close');
        if (closeBtn) {
          closeBtn.addEventListener('click', hideDeviationReview);
        }

        // Close button (alternative)
        const closeBtn2 = document.getElementById('close-deviation-review');
        if (closeBtn2) {
          closeBtn2.addEventListener('click', hideDeviationReview);
        }

        // Export button
        const exportBtn = document.getElementById('export-deviations-btn');
        if (exportBtn) {
          exportBtn.addEventListener('click', exportDeviations);
        }

        // Click outside modal to close
        window.addEventListener('click', function (event) {
          const modal = document.getElementById('deviation-review-modal');
          if (event.target === modal) {
            hideDeviationReview();
          }
        });
      }

      function handleDeviationSubmission() {
        const form = document.getElementById('deviation-form');

        // Validate required fields
        const analystName = document.getElementById('analyst-name').value.trim();
        const reason = document.getElementById('deviation-reason').value;
        const description = document.getElementById('deviation-description').value.trim();

        // Detailed validation with specific error messages
        if (!analystName) {
          alert('❌ Analyst name is required.');
          document.getElementById('analyst-name').focus();
          return;
        }

        if (!reason) {
          alert('❌ Please select a reason for data modification.');
          document.getElementById('deviation-reason').focus();
          return;
        }

        if (!description || description.length < 10) {
          alert('❌ Please provide a detailed description (minimum 10 characters).');
          document.getElementById('deviation-description').focus();
          return;
        }

        // Create deviation record
        const deviation = {
          id: `DEV-${Date.now()}`,
          timestamp: new Date().toISOString(),
          analyst: analystName,
          reason: reason,
          description: description,
          unlockTime: new Date().toISOString(),
          relockTime: null
        };

        // Store deviation
        dataIntegrityState.deviations.push(deviation);
        dataIntegrityState.currentDeviation = deviation;

        // Save to hidden field for persistence
        updateDeviationStorage();

        // Unlock data
        applyDataProtection(false);
        dataIntegrityState.isLocked = false;

        // Update UI
        updateProtectionUI();
        hideDeviationModal();

        console.log('Deviation logged and data unlocked:', deviation);

        // Show success message with deviation details
        alert(
          `✅ DEVIATION LOGGED SUCCESSFULLY\n\n` +
          `Deviation ID: ${deviation.id}\n` +
          `Analyst: ${analystName}\n` +
          `Reason: ${reason}\n` +
          `Time: ${new Date().toLocaleString()}\n\n` +
          `⚠️ Data is now unlocked for editing. Remember to lock data when finished.`
        );
      }

      function updateDeviationStorage() {
        // Store deviations in a hidden field for persistence
        let deviationField = getDeviationField();
        if (!deviationField) {
          deviationField = document.createElement('textarea');
          deviationField.name = getFieldName('ws_deviations');
          deviationField.style.display = 'none';
          document.body.appendChild(deviationField);
        }
        deviationField.value = JSON.stringify(dataIntegrityState.deviations);
      }

      function updateDeviationSummary() {
        const summaryDiv = document.getElementById('deviation-summary');
        const deviationCount = dataIntegrityState.deviations.length;

        if (deviationCount === 0) {
          summaryDiv.innerHTML = `
            <span style="color: #28a745;">✅ No deviations logged.</span><br>
            <small>All instrument data remains unmodified.</small>
        `;
        } else {
          const currentDeviation = dataIntegrityState.currentDeviation;
          if (currentDeviation && !dataIntegrityState.isLocked) {
            summaryDiv.innerHTML = `
                <div style="padding: 8px; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">
                    <strong style="color: #856404;">🔓 ACTIVE DEVIATION</strong><br>
                    <strong>ID:</strong> ${currentDeviation.id}<br>
                    <strong>Analyst:</strong> ${currentDeviation.analyst}<br>
                    <strong>Reason:</strong> ${currentDeviation.reason}<br>
                    <strong>Unlocked:</strong> ${new Date(currentDeviation.timestamp).toLocaleString()}<br>
                    <small style="color: #dc3545;">⚠️ Data is currently unlocked for editing</small>
                </div>
            `;
          } else {
            const lastDeviation = dataIntegrityState.deviations[deviationCount - 1];
            summaryDiv.innerHTML = `
                <div style="padding: 8px; background-color: #d4edda; border: 1px solid #28a745; border-radius: 4px;">
                    <strong style="color: #155724;">📋 Deviations Summary</strong><br>
                    <strong>Total Logged:</strong> ${deviationCount}<br>
                    <strong>Last:</strong> ${lastDeviation.id}<br>
                    <strong>Time:</strong> ${new Date(lastDeviation.timestamp).toLocaleString()}<br>
                    <strong>Analyst:</strong> ${lastDeviation.analyst}
                </div>
            `;
          }
        }

        // Update tab indicators if data is unlocked
        updateTabIndicators();
      }

      function updateTabIndicators() {
        const testTabs = document.querySelectorAll('.ws-tab-btn[data-ws-tab]');
        testTabs.forEach(tab => {
          const tabText = tab.textContent;
          const baseText = tabText.replace(' 🔓', '').replace(' 🔒', '');
          const testId = tab.getAttribute('data-ws-tab');

          // Skip non-test tabs (summary, statistics, settings, sample-info)
          if (['summary', 'statistics', 'settings', 'sample-info'].includes(testId)) {
            return;
          }

          // Get test status and apply color
          const testStatus = getTestStatus(testId);
          const testStatusColors = getTestStatusColors();
          const statusColor = testStatusColors[testStatus] || '#cccccc';

          // Apply status-based background color
          tab.style.backgroundColor = statusColor;
          tab.style.borderLeft = `4px solid ${statusColor}`;

          // Adjust text color for readability based on background
          const isDark = isColorDark(statusColor);
          tab.style.color = isDark ? '#ffffff' : '#000000';

          // Add data integrity indicators
          if (!dataIntegrityState.isLocked && dataIntegrityState.currentDeviation) {
            // Add unlock indicator (keep original tab styling)
            tab.textContent = baseText + ' 🔓';
            tab.title = `Status: ${testStatus} | Data is unlocked for editing - deviation active`;
          } else {
            // Add lock indicator (keep original tab styling)  
            tab.textContent = baseText + ' 🔒';
            tab.title = `Status: ${testStatus} | Data is protected by integrity controls`;
          }

          // Add status indicator to title for additional context
          tab.setAttribute('data-test-status', testStatus);
        });
      }

      // Helper function to determine if a color is dark (for text contrast)
      function isColorDark(hexColor) {
        // Remove # if present
        const hex = hexColor.replace('#', '');

        // Convert to RGB
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);

        // Calculate luminance using standard formula
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

        // Return true if dark (luminance < 0.5)
        return luminance < 0.5;
      }

      // Deviation Review Functions
      function showDeviationReview() {
        const modal = document.getElementById('deviation-review-modal');
        const content = document.getElementById('deviation-review-content');

        // Load and display current deviations
        const deviations = dataIntegrityState.deviations || [];

        if (deviations.length === 0) {
          content.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #666;">
                <h4>✅ No Deviations Found</h4>
                <p>No data integrity deviations have been logged for this worksheet.</p>
                <p><small>This indicates that all instrument data and analyte inclusions remain unmodified.</small></p>
            </div>
        `;
        } else {
          content.innerHTML = generateDeviationReviewHTML(deviations);
        }

        modal.style.display = 'block';
      }

      function generateDeviationReviewHTML(deviations) {
        let html = `
        <div style="margin-bottom: 15px;">
            <strong>Total Deviations:</strong> ${deviations.length}
            <span style="margin-left: 20px; color: #666;">Click any deviation for full details</span>
        </div>
        <div class="deviation-list">
    `;

        deviations.forEach((deviation, index) => {
          const unlockTime = new Date(deviation.unlockTime).toLocaleString();
          const relockTime = deviation.relockTime ? new Date(deviation.relockTime).toLocaleString() : 'Still Unlocked';
          const duration = deviation.relockTime
            ? Math.round((new Date(deviation.relockTime) - new Date(deviation.unlockTime)) / (1000 * 60)) + ' minutes'
            : 'Ongoing';

          const statusClass = deviation.relockTime ? 'deviation-completed' : 'deviation-active';
          const statusText = deviation.relockTime ? 'Completed' : 'Active';

          html += `
            <div class="deviation-item ${statusClass}" onclick="toggleDeviationDetails(${index})">
                <div class="deviation-header">
                    <span class="deviation-id">${deviation.id}</span>
                    <span class="deviation-status">${statusText}</span>
                    <span class="deviation-time">${unlockTime}</span>
                </div>
                <div class="deviation-summary">
                    <strong>Analyst:</strong> ${deviation.analyst} | 
                    <strong>Reason:</strong> ${deviation.reason} | 
                    <strong>Duration:</strong> ${duration}
                </div>
                <div class="deviation-details" id="deviation-details-${index}" style="display: none;">
                    <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                        <h5>Detailed Description:</h5>
                        <p style="margin: 5px 0; white-space: pre-wrap;">${deviation.description}</p>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0;">
                        <div><strong>Unlock Time:</strong><br>${unlockTime}</div>
                        <div><strong>Relock Time:</strong><br>${relockTime}</div>
                        <div><strong>Duration:</strong><br>${duration}</div>
                        <div></div>
                    </div>
                </div>
            </div>
        `;
        });

        html += '</div>';
        return html;
      }

      function toggleDeviationDetails(index) {
        const details = document.getElementById(`deviation-details-${index}`);
        const isVisible = details.style.display !== 'none';
        details.style.display = isVisible ? 'none' : 'block';
      }

      function hideDeviationReview() {
        document.getElementById('deviation-review-modal').style.display = 'none';
      }

      function exportDeviations() {
        const deviations = dataIntegrityState.deviations || [];

        if (deviations.length === 0) {
          alert('No deviations to export.');
          return;
        }

        // Get sample ID and assay display name for traceability
        const sampleInfo = JSON.parse(getElementById("ws-sample-info")?.textContent || "{}");
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const sampleId = sampleInfo.sample_id || "Not specified";
        const assayDisplayName = wsUnitConfig.assay_display_name || wsUnitConfig.assay_name || "Not specified";

        // Create CSV content
        let csvContent = 'Sample ID,Assay Display Name,Deviation ID,Timestamp,Analyst,Reason,Description,Unlock Time,Relock Time,Duration (minutes)\n';

        deviations.forEach(deviation => {
          const unlockTime = new Date(deviation.unlockTime).toISOString();
          const relockTime = deviation.relockTime ? new Date(deviation.relockTime).toISOString() : '';
          const duration = deviation.relockTime
            ? Math.round((new Date(deviation.relockTime) - new Date(deviation.unlockTime)) / (1000 * 60))
            : '';

          // Escape CSV fields
          const escapeCSV = (str) => str.toString().replace(/"/g, '""');

          csvContent += [
            escapeCSV(sampleId),
            escapeCSV(assayDisplayName),
            deviation.id,
            deviation.timestamp,
            escapeCSV(deviation.analyst),
            escapeCSV(deviation.reason),
            `"${escapeCSV(deviation.description)}"`,
            unlockTime,
            relockTime,
            duration
          ].join(',') + '\n';
        });

        // Download CSV
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `deviations_${new Date().toISOString().split('T')[0]}.csv`;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        console.log('Deviations exported successfully');
      }

      // Function to get test status from Jinja data
      function getTestStatus(testId) {
        const testTab = getElementById(`ws-tab-${testId}`);
        const statusElement = testTab?.querySelector('#test-status');
        return statusElement?.textContent?.trim() || "NOT STARTED";
      }

      // Function to get test status colors from kvstore configuration
      function getTestStatusColors() {
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        return wsUnitConfig.test_status_colors || {
          "NOT STARTED": "#ffbd4a",
          "IN PROGRESS": "#34d3eb",
          "COMPLETED": "#81c868",
          "CANCELLED": "#f05050"
        };
      }

      // Function to handle cancelled test data exclusion
      function handleCancelledTests() {
        // Find all test tabs and check their status
        const testTabs = document.querySelectorAll('.ws-tab-btn[data-ws-tab]');

        testTabs.forEach(tab => {
          const testId = tab.getAttribute('data-ws-tab');

          // Skip non-test tabs
          if (['summary', 'statistics', 'settings', 'sample-info'].includes(testId)) {
            return;
          }

          const testStatus = getTestStatus(testId);

          if (testStatus === 'CANCELLED') {
            // Find all include checkboxes for this test
            const includeCheckboxes = document.querySelectorAll(`input[name^="ws_include_"][name$="_${testId}"]`);
            const includeAllCheckbox = document.querySelector(`input[name="ws_include_all_${testId}"]`);

            // Uncheck and disable all include checkboxes for cancelled tests
            includeCheckboxes.forEach(checkbox => {
              checkbox.checked = false;
              checkbox.disabled = true;
              checkbox.title = "Test is CANCELLED - data excluded from calculations";

              // Add visual styling to indicate disabled state
              const row = checkbox.closest('tr');
              if (row) {
                row.style.opacity = '0.5';
                row.style.backgroundColor = '#f8f9fa';
              }
            });

            // Also disable the "include all" checkbox for this test
            if (includeAllCheckbox) {
              includeAllCheckbox.checked = false;
              includeAllCheckbox.disabled = true;
              includeAllCheckbox.title = "Test is CANCELLED - all data excluded from calculations";
            }

            // Disable instrument input fields to prevent data entry
            const instrumentInputs = document.querySelectorAll(`input[name^="ws_instrument_"][name$="_${testId}"]`);
            instrumentInputs.forEach(input => {
              input.disabled = true;
              input.style.backgroundColor = '#e9ecef';
              input.title = "Test is CANCELLED - data entry disabled";
            });

            console.log(`Test ${testId} is CANCELLED - excluded all data from calculations`);
          }
        });
      }

      // Table sorting functionality
      let sortStates = {}; // Track sort state for each table

      function getSortValue(cell) {
        // Extract text content, removing HTML tags for sorting
        const text = cell.textContent.trim();

        // Handle empty/no data cases
        if (text === '' || text === '-' || text === 'NT') {
          return { type: 'empty', value: text, sortOrder: 9999 };
        }

        // Handle special analytical values
        if (text === 'ND') {
          return { type: 'special', value: text, sortOrder: -9999 };
        }

        if (text.startsWith('<') || text.includes('LOQ')) {
          // Extract numeric part for sorting, e.g., "<LOQ" or "<0.1"
          const numMatch = text.match(/[\d.]+/);
          const numValue = numMatch ? parseFloat(numMatch[0]) : 0;
          return { type: 'special', value: text, sortOrder: numValue - 0.001 }; // Sort just below the actual value
        }

        // Handle percentage values
        if (text.endsWith('%')) {
          const numValue = parseFloat(text.replace('%', ''));
          return { type: 'numeric', value: isNaN(numValue) ? 0 : numValue, sortOrder: numValue };
        }

        // Handle numeric values
        const numValue = parseFloat(text);
        if (!isNaN(numValue)) {
          return { type: 'numeric', value: numValue, sortOrder: numValue };
        }

        // Handle status values (Pass/Fail) - custom order, ignore icons
        const cleanText = text.replace(/[✓✗⚠–]/g, '').trim();
        if (cleanText === 'Pass') {
          return { type: 'status', value: cleanText, sortOrder: 1 };
        }
        if (cleanText === 'Fail') {
          return { type: 'status', value: cleanText, sortOrder: 2 };
        }

        // Handle text values
        return { type: 'text', value: text, sortOrder: text.toLowerCase() };
      }

      function sortTable(tableBody, columnIndex, ascending = true) {
        const rows = Array.from(tableBody.querySelectorAll('tr'));

        rows.sort((a, b) => {
          const cellA = a.cells[columnIndex];
          const cellB = b.cells[columnIndex];

          if (!cellA || !cellB) return 0;

          const valueA = getSortValue(cellA);
          const valueB = getSortValue(cellB);

          // Compare sort orders
          let comparison = 0;

          if (typeof valueA.sortOrder === 'string' && typeof valueB.sortOrder === 'string') {
            comparison = valueA.sortOrder.localeCompare(valueB.sortOrder);
          } else {
            comparison = valueA.sortOrder - valueB.sortOrder;
          }

          return ascending ? comparison : -comparison;
        });

        // Re-append sorted rows
        rows.forEach(row => tableBody.appendChild(row));
      }

      function initializeSorting() {
        // Initialize sorting for Summary table
        const summaryHeaders = document.querySelectorAll('#ws-tab-summary .summary-sortable');
        summaryHeaders.forEach((header, index) => {
          header.addEventListener('click', () => {
            const tableBody = document.querySelector('#ws-summary-body');
            const tableId = 'summary';

            // Toggle sort direction
            if (!sortStates[tableId]) sortStates[tableId] = {};
            if (!sortStates[tableId][index]) sortStates[tableId][index] = 'none';

            let newDirection;
            if (sortStates[tableId][index] === 'none' || sortStates[tableId][index] === 'desc') {
              newDirection = 'asc';
            } else {
              newDirection = 'desc';
            }

            sortStates[tableId][index] = newDirection;

            // Clear other column sort indicators
            summaryHeaders.forEach((h, i) => {
              if (i !== index) {
                h.classList.remove('sort-asc', 'sort-desc');
                if (sortStates[tableId][i]) sortStates[tableId][i] = 'none';
              }
            });

            // Update visual indicators
            header.classList.remove('sort-asc', 'sort-desc');
            header.classList.add(newDirection === 'asc' ? 'sort-asc' : 'sort-desc');

            // Sort the table
            sortTable(tableBody, index, newDirection === 'asc');
          });
        });

        // Initialize sorting for Statistics table
        const statsHeaders = document.querySelectorAll('#ws-tab-statistics .stats-sortable');
        statsHeaders.forEach((header, index) => {
          header.addEventListener('click', () => {
            const tableBody = document.querySelector('#ws-statistics-body');
            const tableId = 'statistics';

            // Toggle sort direction
            if (!sortStates[tableId]) sortStates[tableId] = {};
            if (!sortStates[tableId][index]) sortStates[tableId][index] = 'none';

            let newDirection;
            if (sortStates[tableId][index] === 'none' || sortStates[tableId][index] === 'desc') {
              newDirection = 'asc';
            } else {
              newDirection = 'desc';
            }

            sortStates[tableId][index] = newDirection;

            // Clear other column sort indicators
            statsHeaders.forEach((h, i) => {
              if (i !== index) {
                h.classList.remove('sort-asc', 'sort-desc');
                if (sortStates[tableId][i]) sortStates[tableId][i] = 'none';
              }
            });

            // Update visual indicators
            header.classList.remove('sort-asc', 'sort-desc');
            header.classList.add(newDirection === 'asc' ? 'sort-asc' : 'sort-desc');

            // Sort the table
            sortTable(tableBody, index, newDirection === 'asc');
          });
        });
      }

      // Initialize compliance checkbox based on saved settings or kvstore default
      function initializeComplianceCheckbox() {
        const complianceCheckbox = getElementById("compliance-checkbox");
        if (!complianceCheckbox) return;

        // Try to restore from saved user settings first
        const savedSettings = getSavedUserSettings();
        if (savedSettings && savedSettings.compliance_enabled !== undefined) {
          complianceCheckbox.checked = savedSettings.compliance_enabled;
          console.log("Compliance checkbox restored from saved settings:", savedSettings.compliance_enabled);
          return;
        }

        // Fallback to kvstore default value for first-time loads
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");
        const defaultCompliance = wsUnitConfig.default_compliance !== undefined ? wsUnitConfig.default_compliance : true;

        complianceCheckbox.checked = defaultCompliance;
        console.log("Compliance checkbox initialized to kvstore default:", defaultCompliance);
      }

      // Get saved user settings from final results (if available)
      function getSavedUserSettings() {
        try {
          const finalField = getFinalField();
          if (!finalField || !finalField.value) return null;

          const finalResults = JSON.parse(finalField.value);
          return finalResults.user_settings || null;
        } catch (e) {
          console.log("No saved user settings found or parse error:", e.message);
          return null;
        }
      }

      // Restore all user settings from saved data or use defaults
      function restoreUserSettings() {
        const savedSettings = getSavedUserSettings();
        const wsUnitConfig = JSON.parse(getElementById("ws-unit-config")?.textContent || "{}");

        if (!savedSettings) {
          console.log("No saved settings found, using kvstore defaults");

          // Initialize compliance checkbox to kvstore default for first-time loads
          const complianceCheckbox = getElementById("compliance-checkbox");
          if (complianceCheckbox) {
            const defaultCompliance = wsUnitConfig.default_compliance !== undefined ? wsUnitConfig.default_compliance : true;
            complianceCheckbox.checked = defaultCompliance;
            console.log("Compliance checkbox initialized to kvstore default:", defaultCompliance);
          }

          // Initialize uncertainty checkbox to kvstore default (or false if no default)
          const uncertaintyCheckbox = getElementById("uncertainty-checkbox");
          if (uncertaintyCheckbox) {
            const defaultUncertainty = wsUnitConfig.default_uncertainty !== undefined ? wsUnitConfig.default_uncertainty : false;
            uncertaintyCheckbox.checked = defaultUncertainty;
            console.log("Uncertainty checkbox initialized to kvstore default:", defaultUncertainty);
          }

          // Initialize homogeneity checkbox to kvstore default (or false if no default)
          const homogeneityCheckbox = getElementById("homogeneity-enabled");
          if (homogeneityCheckbox) {
            const defaultHomogeneity = wsUnitConfig.default_homogeneity !== undefined ? wsUnitConfig.default_homogeneity : false;
            homogeneityCheckbox.checked = defaultHomogeneity;
            console.log("Homogeneity checkbox initialized to kvstore default:", defaultHomogeneity);
          }

          // Initialize decimal places input to kvstore default (or 3 if no default)
          const sigFigInput = getElementById("sig-fig-input");
          if (sigFigInput) {
            const defaultDecimalPlaces = wsUnitConfig.default_decimal_places !== undefined ? wsUnitConfig.default_decimal_places : 3;
            sigFigInput.value = defaultDecimalPlaces;
            console.log("Decimal places input initialized to kvstore default:", defaultDecimalPlaces);
          }

          // Initialize LOD display checkbox to kvstore default (or true if no default)
          const lodCheckbox = getElementById("lod-display-enabled");
          if (lodCheckbox) {
            const defaultLodDisplay = wsUnitConfig.default_lod_display !== undefined ? wsUnitConfig.default_lod_display : true;
            lodCheckbox.checked = defaultLodDisplay;
            console.log("LOD display checkbox initialized to kvstore default:", defaultLodDisplay);
          }

          return false; // Indicate we're using defaults
        }

        console.log("Restoring saved user settings:", savedSettings);

        // Restore compliance mode
        const complianceCheckbox = getElementById("compliance-checkbox");
        if (complianceCheckbox && savedSettings.compliance_enabled !== undefined) {
          complianceCheckbox.checked = savedSettings.compliance_enabled;
        }

        // Restore uncertainty mode
        const uncertaintyCheckbox = getElementById("uncertainty-checkbox");
        if (uncertaintyCheckbox && savedSettings && savedSettings.uncertainty_enabled !== undefined) {
          uncertaintyCheckbox.checked = savedSettings.uncertainty_enabled;
        }

        // Restore RSD settings
        const rsdWarningInput = getElementById("rsd-warning-limit");
        const rsdFailInput = getElementById("rsd-fail-limit");
        const rsdEnabledCheckbox = getElementById("rsd-check-enabled");

        if (rsdWarningInput && savedSettings.rsd_warning_limit !== undefined) {
          rsdWarningInput.value = savedSettings.rsd_warning_limit;
        }
        if (rsdFailInput && savedSettings.rsd_fail_limit !== undefined) {
          rsdFailInput.value = savedSettings.rsd_fail_limit;
        }
        if (rsdEnabledCheckbox && savedSettings.rsd_check_enabled !== undefined) {
          rsdEnabledCheckbox.checked = savedSettings.rsd_check_enabled;
        }

        // Restore decimal places setting
        const sigFigInput = getElementById("sig-fig-input");
        if (sigFigInput && savedSettings.sig_figs !== undefined) {
          sigFigInput.value = savedSettings.sig_figs;
        }

        // Restore moisture correction settings
        const moistureCorrectionCheckbox = getElementById("moisture-correction-enabled");
        const moistureReportingCheckbox = getElementById("moisture-reporting-enabled");

        if (moistureCorrectionCheckbox && savedSettings.moisture_correction_enabled !== undefined) {
          moistureCorrectionCheckbox.checked = savedSettings.moisture_correction_enabled;
        }
        if (moistureReportingCheckbox && savedSettings.moisture_reporting_enabled !== undefined) {
          moistureReportingCheckbox.checked = savedSettings.moisture_reporting_enabled;
        }

        // Restore LOD display setting
        const lodCheckbox = getElementById("lod-display-enabled");
        if (lodCheckbox && savedSettings.lod_display_enabled !== undefined) {
          lodCheckbox.checked = savedSettings.lod_display_enabled;
        }

        // Restore homogeneity setting
        const homogeneityCheckbox = getElementById("homogeneity-enabled");
        if (homogeneityCheckbox && savedSettings.homogeneity_enabled !== undefined) {
          homogeneityCheckbox.checked = savedSettings.homogeneity_enabled;
        }

        // Restore report above curve setting
        const reportAboveCurveCheckbox = getElementById("report-above-curve-checkbox");
        if (reportAboveCurveCheckbox && savedSettings.report_above_curve_enabled !== undefined) {
          reportAboveCurveCheckbox.checked = savedSettings.report_above_curve_enabled;
        }

        // Update moisture display to reflect restored settings
        updateMoistureDisplay();

        return true; // Indicate we restored from saved settings
      }

      // Initialization completed in main $(document).ready block above
    })(); // end initQBenchWorksheetInstance
  </script>
</div>
<!-- End QBench Worksheet Container -->